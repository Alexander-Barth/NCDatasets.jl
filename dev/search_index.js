var documenterSearchIndex = {"docs":
[{"location":"#NCDatasets.jl-1","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Documentation for NCDatasets.jl","category":"page"},{"location":"#Installation-1","page":"NCDatasets.jl","title":"Installation","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Inside the Julia shell, you can download and install the package by issuing:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"using Pkg\nPkg.add(\"NCDatasets\")","category":"page"},{"location":"#Latest-development-version-1","page":"NCDatasets.jl","title":"Latest development version","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"If you want to try the latest development version, you can do this with the following commands:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/Alexander-Barth/NCDatasets.jl\", rev=\"master\"))\nPkg.build(\"NCDatasets\")","category":"page"},{"location":"#Tutorial-1","page":"NCDatasets.jl","title":"Tutorial","text":"","category":"section"},{"location":"#Load-a-variable-from-a-netCDF-file-1","page":"NCDatasets.jl","title":"Load a variable from a netCDF file","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"In the following example, we load the variable with the name tp from the NetCDF file \"ECMWF_ERA-40_subset.nc\" and the attribute named \"units\":.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"using NCDatasets\ndownload(\"https://www.unidata.ucar.edu/software/netcdf/examples/ECMWF_ERA-40_subset.nc\",\"ECMWF_ERA-40_subset.nc\");\nds = Dataset(\"ECMWF_ERA-40_subset.nc\")\ntp = ds[\"tp\"][:];\ntp_units = ds[\"tp\"].attrib[\"units\"]\nclose(ds)","category":"page"},{"location":"#Create-a-netCDF-file-using-the-metadata-of-an-existing-netCDF-file-as-template-1","page":"NCDatasets.jl","title":"Create a netCDF file using the metadata of an existing netCDF file as template","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"The utility function ncgen generates the Julia code that would produce a netCDF file with the same metadata as a template netCDF file. It is thus similar to the command line tool ncgen.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"# download example file\nncfile = download(\"https://www.unidata.ucar.edu/software/netcdf/examples/sresa1b_ncar_ccsm3-example.nc\")\n# generate Julia code\nncgen(ncfile)","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"The produces the Julia code (only the beginning of the code is shown):","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"ds = Dataset(\"filename.nc\",\"c\")\n# Dimensions\n\nds.dim[\"lat\"] = 128;\nds.dim[\"lon\"] = 256;\nds.dim[\"bnds\"] = 2;\nds.dim[\"plev\"] = 17;\nds.dim[\"time\"] = 1;\n\n# Declare variables\n\nncarea = defVar(ds,\"area\", Float32, (\"lon\", \"lat\"))\nncarea.attrib[\"long_name\"] = \"Surface area\";\nncarea.attrib[\"units\"] = \"meter2\";\n# ...","category":"page"},{"location":"#Get-one-or-several-variables-by-specifying-the-value-of-an-attribute-1","page":"NCDatasets.jl","title":"Get one or several variables by specifying the value of an attribute","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"The variable name are not always standardized, for example the longitude we can find: lon, LON, longitude, ...","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"The solution implemented in the function varbyattrib consists in searching for the variables that have specified value for a given attribute.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"nclon = varbyattrib(ds, standard_name=\"longitude\");","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"will return the list of variables of the dataset ds that have \"longitude\" as standard name. To directly load the data of the first variable with the attribute standard_name equal to \"longitude\" one can the following:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"data = varbyattrib(ds, standard_name = \"longitude\")[1][:]","category":"page"},{"location":"#Load-a-file-(with-unknown-structure)-1","page":"NCDatasets.jl","title":"Load a file (with unknown structure)","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"If the structure of the netCDF file is not known before-hand, the program must check if a variable or attribute exists (with the haskey function) before loading it or alternatively place the loading in a try-catch block. It is also possible to iterate over all variables or attributes (global attributes or variable attributes) in the same syntax as iterating over a dictionary. However, unlike Julia dictionaries, the order of the attributes and variables is preserved and presented as they are stored in the netCDF file.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"# Open a file as read-only\nds = Dataset(\"/tmp/test.nc\",\"r\")\n\n# check if a file has a variable with a given name\nif haskey(ds,\"temperature\")\n    println(\"The file has a variable 'temperature'\")\nend\n\n# get a list of all variable names\n@show keys(ds)\n\n# iterate over all variables\nfor (varname,var) in ds\n    @show (varname,size(var))\nend\n\n# query size of a variable (without loading it)\nv = ds[\"temperature\"]\n@show size(v)\n\n# similar for global and variable attributes\n\nif haskey(ds.attrib,\"title\")\n    println(\"The file has the global attribute 'title'\")\nend\n\n# get an list of all attribute names\n@show keys(ds.attrib)\n\n# iterate over all attributes\nfor (attname,attval) in ds.attrib\n    @show (attname,attval)\nend\n\n# get the attribute \"units\" of the variable v\n# but return the default value (here \"adimensional\")\n# if the attribute does not exists\n\nunits = get(v,\"units\",\"adimensional\")\nclose(ds)","category":"page"},{"location":"#Datasets-1","page":"NCDatasets.jl","title":"Datasets","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Dataset\nkeys(ds::Dataset)\nhaskey\ngetindex(ds::Dataset,varname::AbstractString)\nvariable\nsync\nclose\npath","category":"page"},{"location":"#NCDatasets.Dataset","page":"NCDatasets.jl","title":"NCDatasets.Dataset","text":"Dataset(filename::AbstractString,mode::AbstractString = \"r\";\n                 format::Symbol = :netcdf4, attrib = [])\n\nCreate a new NetCDF file if the mode is \"c\". An existing file with the same name will be overwritten. If mode is \"a\", then an existing file is open into append mode (i.e. existing data in the netCDF file is not overwritten and a variable can be added). With the mode set to \"r\", an existing netCDF file or OPeNDAP URL can be open in read-only mode.  The default mode is \"r\". The optional parameter attrib is an iterable of attribute name and attribute value pairs, for example a Dict, DataStructures.OrderedDict or simply a vector of pairs (see example below).\n\nSupported formats:\n\n:netcdf4 (default): HDF5-based NetCDF format.\n:netcdf4_classic: Only netCDF 3 compatible API features will be used.\n:netcdf3_classic: classic netCDF format supporting only files smaller than 2GB.\n:netcdf3_64bit_offset: improved netCDF format supporting files larger than 2GB.\n\nFiles can also be open and automatically closed with a do block.\n\nDataset(\"file.nc\") do ds\n    data = ds[\"temperature\"][:,:]\nend\n\nDataset(\"file.nc\", \"c\", attrib = [\"title\" => \"my first netCDF file\"]) do ds\n   defVar(ds,\"temp\",[10.,20.,30.],(\"time\",))\nend;\n\n\n\n\n\nmfds = Dataset(fnames,mode = \"r\"; aggdim = nothing, deferopen = true)\n\nOpens a multi-file dataset in read-only \"r\" or append mode \"a\". fnames is a vector of file names. Variables are aggregated over the first unlimited dimension or over the dimension aggdim if specified. The append mode is only implemented when deferopen is false.\n\nAll variables containing the dimension aggdim are aggregated. The variable who do not contain the dimension aggdim are assumed constant.\n\nIf deferopen is false, all files are opened at the same time. However the operating system might limit the number of open files. In Linux, the limit can be controled with the command ulimit [1,2].\n\n[1]: https://stackoverflow.com/questions/34588/how-do-i-change-the-number-of-open-files-limit-in-linux [2]: https://unix.stackexchange.com/questions/8945/how-can-i-increase-open-files-limit-for-all-processes/8949#8949\n\n\n\n\n\n","category":"type"},{"location":"#Base.keys-Tuple{Dataset}","page":"NCDatasets.jl","title":"Base.keys","text":"keys(ds::Dataset)\n\nReturn a list of all variables names in Dataset ds.\n\n\n\n\n\n","category":"method"},{"location":"#Base.haskey","page":"NCDatasets.jl","title":"Base.haskey","text":"haskey(ds::Dataset,varname)\n\nReturn true if the Dataset ds has a variable with the name varname. For example:\n\nds = Dataset(\"/tmp/test.nc\",\"r\")\nif haskey(ds,\"temperature\")\n    println(\"The file has a variable 'temperature'\")\nend\n\nThis example checks if the file /tmp/test.nc has a variable with the name temperature.\n\n\n\n\n\n","category":"function"},{"location":"#Base.getindex-Tuple{Dataset,AbstractString}","page":"NCDatasets.jl","title":"Base.getindex","text":"v = getindex(ds::Dataset,varname::AbstractString)\n\nReturn the NetCDF variable varname in the dataset ds as a NCDataset.CFVariable. The CF convention are honored when the variable is indexed:\n\n_FillValue will be returned as missing\nscale_factor and add_offset are applied\ntime variables (recognized by the units attribute) are returned as DateTime object.\n\nA call getindex(ds,varname) is usually written as ds[varname].\n\n\n\n\n\n","category":"method"},{"location":"#NCDatasets.variable","page":"NCDatasets.jl","title":"NCDatasets.variable","text":"v = variable(ds::Dataset,varname::String)\n\nReturn the NetCDF variable varname in the dataset ds as a NCDataset.Variable. No scaling or other transformations are applied when the variable v is indexed.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.sync","page":"NCDatasets.jl","title":"NCDatasets.sync","text":"sync(ds::Dataset)\n\nWrite all changes in Dataset ds to the disk.\n\n\n\n\n\n","category":"function"},{"location":"#Base.close","page":"NCDatasets.jl","title":"Base.close","text":"close(ds::Dataset)\n\nClose the Dataset ds. All pending changes will be written to the disk.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.path","page":"NCDatasets.jl","title":"NCDatasets.path","text":"path(ds::Dataset)\n\nReturn the file path (or the opendap URL) of the Dataset ds\n\n\n\n\n\n","category":"function"},{"location":"#Variables-1","page":"NCDatasets.jl","title":"Variables","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"defVar\ndimnames\nname\nchunking\ndeflate\nchecksum\nloadragged","category":"page"},{"location":"#NCDatasets.defVar","page":"NCDatasets.jl","title":"NCDatasets.defVar","text":"defVar(ds::Dataset,name,vtype,dimnames; kwargs...)\ndefVar(ds::Dataset,name,data,dimnames; kwargs...)\n\nDefine a variable with the name name in the dataset ds.  vtype can be Julia types in the table below (with the corresponding NetCDF type). Instead of providing the variable type one can directly give also the data data which will be used to fill the NetCDF variable. The parameter dimnames is a tuple with the names of the dimension.  For scalar this parameter is the empty tuple (). The variable is returned (of the type CFVariable).\n\nNote if data is a vector or array of DateTime objects, then the dates are saved as double-precision floats and units \"days since 1900-01-01 00:00:00\" (unless a time unit is specifed with the attrib keyword described below)\n\nKeyword arguments\n\nfillvalue: A value filled in the NetCDF file to indicate missing data.  It will be stored in the _FillValue attribute.\nchunksizes: Vector integers setting the chunk size. The total size of a chunk must be less than 4 GiB.\ndeflatelevel: Compression level: 0 (default) means no compression and 9 means maximum compression. Each chunk will be compressed individually.\nshuffle: If true, the shuffle filter is activated which can improve the compression ratio.\nchecksum: The checksum method can be :fletcher32 or :nochecksum (checksumming is disabled, which is the default)\nattrib: An iterable of attribute name and attribute value pairs, for example a Dict, DataStructures.OrderedDict or simply a vector of pairs (see example below)\ntypename (string): The name of the NetCDF type required for vlen arrays [1]\n\nchunksizes, deflatelevel, shuffle and checksum can only be set on NetCDF 4 files.\n\nNetCDF data types\n\nNetCDF Type Julia Type\nNC_BYTE Int8\nNC_UBYTE UInt8\nNC_SHORT Int16\nNC_INT Int32\nNC_INT64 Int64\nNC_FLOAT Float32\nNC_DOUBLE Float64\nNC_CHAR Char\nNC_STRING String\n\nExample:\n\njulia> data = randn(3,5)\njulia> Dataset(\"test_file.nc\",\"c\") do ds\n          defVar(ds,\"temp\",data,(\"lon\",\"lat\"), attrib = [\n             \"units\" => \"degree_Celsius\",\n             \"long_name\" => \"Temperature\"\n          ])\n       end;\n\n\n[1]: https://web.archive.org/save/https://www.unidata.ucar.edu/software/netcdf/netcdf-4/newdocs/netcdf-c/nc005fdef005fvlen.html\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.dimnames","page":"NCDatasets.jl","title":"NCDatasets.dimnames","text":"dimnames(v::Variable)\n\nReturn a tuple of the dimension names of the variable v.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.name","page":"NCDatasets.jl","title":"NCDatasets.name","text":"name(v::Variable)\n\nReturn the name of the NetCDF variable v.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.chunking","page":"NCDatasets.jl","title":"NCDatasets.chunking","text":"storage,chunksizes = chunking(v::Variable)\n\nReturn the storage type (:contiguous or :chunked) and the chunk sizes of the varable v.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.deflate","page":"NCDatasets.jl","title":"NCDatasets.deflate","text":"isshuffled,isdeflated,deflate_level = deflate(v::Variable)\n\nReturn compression information of the variable v. If shuffle is true, then shuffling (byte interlacing) is activaded. If deflate is true, then the data chunks (see chunking) are compressed using the compression level deflate_level (0 means no compression and 9 means maximum compression).\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.checksum","page":"NCDatasets.jl","title":"NCDatasets.checksum","text":"checksummethod = checksum(v::Variable)\n\nReturn the checksum method of the variable v which can be either be :fletcher32 or :nochecksum.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.loadragged","page":"NCDatasets.jl","title":"NCDatasets.loadragged","text":" data = loadragged(ncvar,index::Colon)\n\nLoad data from ncvar in the contiguous ragged array representation [1] as a vector of vectors. It is typically used to load a list of profiles or time series of different length each.\n\nThe indexed ragged array representation [2] is currently not supported.\n\n[1]: https://web.archive.org/web/20190111092546/http://cfconventions.org/cf-conventions/v1.6.0/cf-conventions.html#contiguousraggedarrayrepresentation [2]: https://web.archive.org/web/20190111092546/http://cfconventions.org/cf-conventions/v1.6.0/cf-conventions.html#indexedraggedarrayrepresentation\n\n\n\n\n\n","category":"function"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Different type of arrays are involved when working with NCDatasets. For instance assume that test.nc is a file with a Float32 variable called var. Assume that we open this data set in append mode (\"a\"):","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"using NCDatasets\nds = Dataset(\"test.nc\",\"a\")\nv_cf = ds[\"var\"]","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"The variable v_cf has the type CFVariable. No data is actually loaded from disk, but you can query its size, number of dimensions, number elements, ... by the functions size, ndims, length as ordinary Julia arrays. Once you index, the variable v_cf, then the data is loaded and stored as an Array:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"v_da = v_cf[:,:] # or v_da = v_cf[:]","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Note that even if the variable v_cf has 2 (or more dimension), the index operation v_cf[:] preserves its actual shape and does not generate a flat vector of the data (unlike regular Julia arrays). As load operations are very common, it was consired advantageous to have a consice syntax.","category":"page"},{"location":"#Attributes-1","page":"NCDatasets.jl","title":"Attributes","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"The NetCDF dataset (as return by Dataset or NetCDF groups) and the NetCDF variables (as returned by getindex, variable or defVar) have the field attrib which has the type NCDatasets.Attributes and behaves like a julia dictionary.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"getindex(a::NCDatasets.Attributes,name::AbstractString)\nsetindex!(a::NCDatasets.Attributes,data,name::AbstractString)\nkeys(a::NCDatasets.Attributes)","category":"page"},{"location":"#Base.getindex-Tuple{NCDatasets.Attributes,AbstractString}","page":"NCDatasets.jl","title":"Base.getindex","text":"getindex(a::Attributes,name::AbstractString)\n\nReturn the value of the attribute called name from the attribute list a. Generally the attributes are loaded by indexing, for example:\n\nds = Dataset(\"file.nc\")\ntitle = ds.attrib[\"title\"]\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Tuple{NCDatasets.Attributes,Any,AbstractString}","page":"NCDatasets.jl","title":"Base.setindex!","text":"Base.setindex!(a::Attributes,data,name::AbstractString)\n\nSet the attribute called name to the value data in the attribute list a. Generally the attributes are defined by indexing, for example:\n\nds = Dataset(\"file.nc\",\"c\")\nds.attrib[\"title\"] = \"my title\"\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{NCDatasets.Attributes}","page":"NCDatasets.jl","title":"Base.keys","text":"Base.keys(a::Attributes)\n\nReturn a list of the names of all attributes.\n\n\n\n\n\n","category":"method"},{"location":"#Dimensions-1","page":"NCDatasets.jl","title":"Dimensions","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"defDim\nsetindex!(d::NCDatasets.Dimensions,len,name::AbstractString)\ndimnames(v::NCDatasets.Variable)\nunlimited(d::NCDatasets.Dimensions)","category":"page"},{"location":"#NCDatasets.defDim","page":"NCDatasets.jl","title":"NCDatasets.defDim","text":"defDim(ds::Dataset,name,len)\n\nDefine a dimension in the data set ds with the given name and length len. If len is the special value Inf, then the dimension is considered as unlimited, i.e. it will grow as data is added to the NetCDF file.\n\nFor example:\n\nds = Dataset(\"/tmp/test.nc\",\"c\")\ndefDim(ds,\"lon\",100)\n\nThis defines the dimension lon with the size 100.\n\n\n\n\n\n","category":"function"},{"location":"#Base.setindex!-Tuple{NCDatasets.Dimensions,Any,AbstractString}","page":"NCDatasets.jl","title":"Base.setindex!","text":"Base.setindex!(d::Dimensions,len,name::AbstractString)\n\nDefines the dimension called name to the length len. Generally dimension are defined by indexing, for example:\n\nds = Dataset(\"file.nc\",\"c\")\nds.dim[\"longitude\"] = 100\n\nIf len is the special value Inf, then the dimension is considered as unlimited, i.e. it will grow as data is added to the NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"#NCDatasets.dimnames-Tuple{NCDatasets.Variable}","page":"NCDatasets.jl","title":"NCDatasets.dimnames","text":"dimnames(v::Variable)\n\nReturn a tuple of the dimension names of the variable v.\n\n\n\n\n\n","category":"method"},{"location":"#NCDatasets.unlimited-Tuple{NCDatasets.Dimensions}","page":"NCDatasets.jl","title":"NCDatasets.unlimited","text":"unlimited(d::Dimensions)\n\nReturn the names of all unlimited dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#Groups-1","page":"NCDatasets.jl","title":"Groups","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"defGroup(ds::Dataset,groupname)\ngetindex(g::NCDatasets.Groups,groupname::AbstractString)\nBase.keys(g::NCDatasets.Groups)","category":"page"},{"location":"#NCDatasets.defGroup-Tuple{Dataset,Any}","page":"NCDatasets.jl","title":"NCDatasets.defGroup","text":"defGroup(ds::Dataset,groupname, attrib = []))\n\nCreate the group with the name groupname in the dataset ds. attrib is a list of attribute name and attribute value pairs (see Dataset).\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{NCDatasets.Groups,AbstractString}","page":"NCDatasets.jl","title":"Base.getindex","text":"group = getindex(g::NCDatasets.Groups,groupname::AbstractString)\n\nReturn the NetCDF group with the name groupname. For example:\n\njulia> ds = Dataset(\"results.nc\", \"r\");\njulia> forecast_group = ds.group[\"forecast\"]\njulia> forecast_temp = forecast_group[\"temperature\"]\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{NCDatasets.Groups}","page":"NCDatasets.jl","title":"Base.keys","text":"Base.keys(g::NCDatasets.Groups)\n\nReturn the names of all subgroubs of the group g.\n\n\n\n\n\n","category":"method"},{"location":"#Common-methods-1","page":"NCDatasets.jl","title":"Common methods","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"One can iterate over a dataset, attribute list, dimensions and NetCDF groups.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"for (varname,var) in ds\n    # all variables\n    @show (varname,size(var))\nend\n\nfor (dimname,dim) in ds.dims\n    # all dimensions\n    @show (dimname,dim)\nend\n\nfor (attribname,attrib) in ds.attrib\n    # all attributes\n    @show (attribname,attrib)\nend\n\nfor (groupname,group) in ds.groups\n    # all groups\n    @show (groupname,group)\nend","category":"page"},{"location":"#Time-functions-1","page":"NCDatasets.jl","title":"Time functions","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"DateTimeStandard\nDateTimeJulian\nDateTimeProlepticGregorian\nDateTimeAllLeap\nDateTimeNoLeap\nDateTime360Day\nNCDatasets.year(dt::AbstractCFDateTime)\nNCDatasets.month(dt::AbstractCFDateTime)\nNCDatasets.day(dt::AbstractCFDateTime)\nNCDatasets.hour(dt::AbstractCFDateTime)\nNCDatasets.minute(dt::AbstractCFDateTime)\nNCDatasets.second(dt::AbstractCFDateTime)\nNCDatasets.millisecond(dt::AbstractCFDateTime)\nconvert\nreinterpret\ndaysinmonth\ndaysinyear\nyearmonthday\nyearmonth\nmonthday\nfirstdayofyear\ndayofyear\nCFTime.timedecode\nCFTime.timeencode","category":"page"},{"location":"#NCDatasets.CFTime.DateTimeStandard","page":"NCDatasets.jl","title":"NCDatasets.CFTime.DateTimeStandard","text":"DateTimeStandard(y, [m, d, h, mi, s, ms]) -> DateTimeStandard\n\nConstruct a DateTimeStandard type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0). All arguments must be convertible to Int64. DateTimeStandard is a subtype of AbstractCFDateTime.\n\nThe netCDF CF calendars are defined at [1].\n\n[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar\n\n\n\n\n\n       DateTimeStandard(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTimeStandard\n\nConstruct a DateTimeStandard by parsing the dt date time string following the pattern given in the format string.\n\nNote: This function is experimental and migth be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#NCDatasets.CFTime.DateTimeJulian","page":"NCDatasets.jl","title":"NCDatasets.CFTime.DateTimeJulian","text":"DateTimeJulian(y, [m, d, h, mi, s, ms]) -> DateTimeJulian\n\nConstruct a DateTimeJulian type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0). All arguments must be convertible to Int64. DateTimeJulian is a subtype of AbstractCFDateTime.\n\nThe netCDF CF calendars are defined at [1].\n\n[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar\n\n\n\n\n\n       DateTimeJulian(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTimeJulian\n\nConstruct a DateTimeJulian by parsing the dt date time string following the pattern given in the format string.\n\nNote: This function is experimental and migth be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#NCDatasets.CFTime.DateTimeProlepticGregorian","page":"NCDatasets.jl","title":"NCDatasets.CFTime.DateTimeProlepticGregorian","text":"DateTimeProlepticGregorian(y, [m, d, h, mi, s, ms]) -> DateTimeProlepticGregorian\n\nConstruct a DateTimeProlepticGregorian type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0). All arguments must be convertible to Int64. DateTimeProlepticGregorian is a subtype of AbstractCFDateTime.\n\nThe netCDF CF calendars are defined at [1].\n\n[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar\n\n\n\n\n\n       DateTimeProlepticGregorian(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTimeProlepticGregorian\n\nConstruct a DateTimeProlepticGregorian by parsing the dt date time string following the pattern given in the format string.\n\nNote: This function is experimental and migth be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#NCDatasets.CFTime.DateTimeAllLeap","page":"NCDatasets.jl","title":"NCDatasets.CFTime.DateTimeAllLeap","text":"DateTimeAllLeap(y, [m, d, h, mi, s, ms]) -> DateTimeAllLeap\n\nConstruct a DateTimeAllLeap type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0). All arguments must be convertible to Int64. DateTimeAllLeap is a subtype of AbstractCFDateTime.\n\nThe netCDF CF calendars are defined at [1].\n\n[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar\n\n\n\n\n\n       DateTimeAllLeap(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTimeAllLeap\n\nConstruct a DateTimeAllLeap by parsing the dt date time string following the pattern given in the format string.\n\nNote: This function is experimental and migth be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#NCDatasets.CFTime.DateTimeNoLeap","page":"NCDatasets.jl","title":"NCDatasets.CFTime.DateTimeNoLeap","text":"DateTimeNoLeap(y, [m, d, h, mi, s, ms]) -> DateTimeNoLeap\n\nConstruct a DateTimeNoLeap type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0). All arguments must be convertible to Int64. DateTimeNoLeap is a subtype of AbstractCFDateTime.\n\nThe netCDF CF calendars are defined at [1].\n\n[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar\n\n\n\n\n\n       DateTimeNoLeap(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTimeNoLeap\n\nConstruct a DateTimeNoLeap by parsing the dt date time string following the pattern given in the format string.\n\nNote: This function is experimental and migth be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#NCDatasets.CFTime.DateTime360Day","page":"NCDatasets.jl","title":"NCDatasets.CFTime.DateTime360Day","text":"DateTime360Day(y, [m, d, h, mi, s, ms]) -> DateTime360Day\n\nConstruct a DateTime360Day type by year (y), month (m, default 1), day (d, default 1), hour (h, default 0), minute (mi, default 0), second (s, default 0), millisecond (ms, default 0). All arguments must be convertible to Int64. DateTime360Day is a subtype of AbstractCFDateTime.\n\nThe netCDF CF calendars are defined at [1].\n\n[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar\n\n\n\n\n\n       DateTime360Day(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTime360Day\n\nConstruct a DateTime360Day by parsing the dt date time string following the pattern given in the format string.\n\nNote: This function is experimental and migth be removed in the future. It relies on some internal function of Dates for parsing the format.\n\n\n\n\n\n","category":"type"},{"location":"#Dates.year-Tuple{AbstractCFDateTime}","page":"NCDatasets.jl","title":"Dates.year","text":"Dates.year(dt::AbstractCFDateTime) -> Int64\n\nExtract the year-part of a AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.month-Tuple{AbstractCFDateTime}","page":"NCDatasets.jl","title":"Dates.month","text":"Dates.month(dt::AbstractCFDateTime) -> Int64\n\nExtract the month-part of a AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.day-Tuple{AbstractCFDateTime}","page":"NCDatasets.jl","title":"Dates.day","text":"Dates.day(dt::AbstractCFDateTime) -> Int64\n\nExtract the day-part of a AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.hour-Tuple{AbstractCFDateTime}","page":"NCDatasets.jl","title":"Dates.hour","text":"Dates.hour(dt::AbstractCFDateTime) -> Int64\n\nExtract the hour-part of a AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.minute-Tuple{AbstractCFDateTime}","page":"NCDatasets.jl","title":"Dates.minute","text":"Dates.minute(dt::AbstractCFDateTime) -> Int64\n\nExtract the minute-part of a AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.second-Tuple{AbstractCFDateTime}","page":"NCDatasets.jl","title":"Dates.second","text":"Dates.second(dt::AbstractCFDateTime) -> Int64\n\nExtract the second-part of a AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Dates.millisecond-Tuple{AbstractCFDateTime}","page":"NCDatasets.jl","title":"Dates.millisecond","text":"Dates.millisecond(dt::AbstractCFDateTime) -> Int64\n\nExtract the millisecond-part of a AbstractCFDateTime as an Int64.\n\n\n\n\n\n","category":"method"},{"location":"#Base.convert","page":"NCDatasets.jl","title":"Base.convert","text":"dt2 = convert(::Type{T}, dt)\n\nConvert a DateTime of type DateTimeStandard, DateTimeProlepticGregorian, DateTimeJulian or DateTime into the type T which can also be either DateTimeStandard, DateTimeProlepticGregorian, DateTimeJulian or DateTime.\n\nConverstion is done such that durations (difference of DateTime types) are preserved. For dates on and after 1582-10-15, the year, month and days are the same for the types DateTimeStandard, DateTimeProlepticGregorian and DateTime.\n\nFor dates before 1582-10-15, the year, month and days are the same for the types DateTimeStandard and DateTimeJulian.\n\n\n\n\n\n","category":"function"},{"location":"#Base.reinterpret","page":"NCDatasets.jl","title":"Base.reinterpret","text":"dt2 = reinterpret(::Type{T}, dt)\n\nConvert a variable dt of type DateTime, DateTimeStandard, DateTimeJulian, DateTimeProlepticGregorian, DateTimeAllLeap, DateTimeNoLeap or DateTime360Day into the date time type T using the same values for year, month, day, minute, second and millisecond. The conversion might fail if a particular date does not exist in the target calendar.\n\n\n\n\n\n","category":"function"},{"location":"#Dates.daysinmonth","page":"NCDatasets.jl","title":"Dates.daysinmonth","text":"monthlength = daysinmonth(::Type{DT},y,m)\n\nReturns the number of days in a month for the year y and the month m according to the calenar given by the type DT.\n\nExample\n\njulia> daysinmonth(DateTimeAllLeap,2001,2)\n29\n\n\n\n\n\nmonthlength = daysinmonth(t)\n\nReturns the number of days in a month containing the date t\n\nExample\n\njulia> daysinmonth(DateTimeAllLeap(2001,2,1))\n29\n\n\n\n\n\n","category":"function"},{"location":"#Dates.daysinyear","page":"NCDatasets.jl","title":"Dates.daysinyear","text":"yearlength = daysinyear(::Type{DT},y)\n\nReturns the number of days in a year for the year y according to the calenar given by the type DT.\n\nExample\n\njulia> daysinyear(DateTimeAllLeap,2001,2)\n366\n\n\n\n\n\nyearlength = daysinyear(t)\n\nReturns the number of days in a year containing the date t\n\nExample\n\njulia> daysinyear(DateTimeAllLeap(2001,2,1))\n366\n\n\n\n\n\n","category":"function"},{"location":"#Dates.yearmonthday","page":"NCDatasets.jl","title":"Dates.yearmonthday","text":"yearmonthday(dt::AbstractCFDateTime) -> (Int64, Int64, Int64)\n\nSimultaneously return the year, month and day parts of dt.\n\n\n\n\n\n","category":"function"},{"location":"#Dates.yearmonth","page":"NCDatasets.jl","title":"Dates.yearmonth","text":"yearmonth(dt::AbstractCFDateTime) -> (Int64, Int64)\n\nSimultaneously return the year and month parts of dt.\n\n\n\n\n\n","category":"function"},{"location":"#Dates.monthday","page":"NCDatasets.jl","title":"Dates.monthday","text":"monthday(dt::AbstractCFDateTime) -> (Int64, Int64)\n\nSimultaneously return the month and day parts of dt.\n\n\n\n\n\n","category":"function"},{"location":"#Dates.firstdayofyear","page":"NCDatasets.jl","title":"Dates.firstdayofyear","text":"firstdayofyear(dt::AbstractCFDateTime) -> Int\n\nReturn the first day of the year including the date dt\n\n\n\n\n\n","category":"function"},{"location":"#Dates.dayofyear","page":"NCDatasets.jl","title":"Dates.dayofyear","text":"dayofyear(dt::AbstractCFDateTime) -> Int\n\nReturn the day of the year for dt with January 1st being day 1.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.CFTime.timedecode","page":"NCDatasets.jl","title":"NCDatasets.CFTime.timedecode","text":"dt = timedecode(data,units,calendar = \"standard\", prefer_datetime = true)\n\nDecode the time information in data as given by the units units according to the specified calendar. Valid values for calendar are \"standard\", \"gregorian\", \"prolepticgregorian\", \"julian\", \"noleap\", \"365day\", \"allleap\", \"366day\" and \"360_day\".\n\nIf prefer_datetime is true (default), dates are converted to the DateTime type (for the calendars \"standard\", \"gregorian\", \"proleptic_gregorian\" and \"julian\"). Such conversion is not possible for the other calendars.\n\nCalendar Type (prefer_datetime=true) Type (prefer_datetime=false)\nstandard, gregorian DateTime DateTimeStandard\nproleptic_gregorian DateTime DateTimeProlepticGregorian\njulian DateTime DateTimeJulian\nnoleap, 365_day DateTimeNoLeap DateTimeNoLeap\nallleap, 366day DateTimeAllLeap DateTimeAllLeap\n360_day DateTime360Day DateTime360Day\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.CFTime.timeencode","page":"NCDatasets.jl","title":"NCDatasets.CFTime.timeencode","text":"data = timeencode(dt,units,calendar = \"standard\")\n\nConvert a vector or array of DateTime (or DateTimeStandard, DateTimeProlepticGregorian, DateTimeJulian, DateTimeNoLeap, DateTimeAllLeap, DateTime360Day) accoring to the specified units (e.g. \"days since 2000-01-01 00:00:00\") using the calendar calendar.  Valid values for calendar are: \"standard\", \"gregorian\", \"prolepticgregorian\", \"julian\", \"noleap\", \"365day\", \"allleap\", \"366day\", \"360_day\".\n\n\n\n\n\n","category":"function"},{"location":"#Utility-functions-1","page":"NCDatasets.jl","title":"Utility functions","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"ncgen\nnomissing\nvarbyattrib","category":"page"},{"location":"#NCDatasets.ncgen","page":"NCDatasets.jl","title":"NCDatasets.ncgen","text":"ncgen(fname; ...)\nncgen(fname,jlname; ...)\n\nGenerate the Julia code that would produce a NetCDF file with the same metadata as the NetCDF file fname. The code is placed in the file jlname or printed to the standard output. By default the new NetCDF file is called filename.nc. This can be changed with the optional parameter newfname.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.nomissing","page":"NCDatasets.jl","title":"NCDatasets.nomissing","text":"a = nomissing(da)\n\nRetun the values of the array da of type Array{Union{T,Missing},N} (potentially containing missing values) as a regular Julia array a of the same element type and checks that no missing values are present.\n\n\n\n\n\na = nomissing(da,value)\n\nRetun the values of the array da of type Array{Union{T,Missing},N} as a regular Julia array a by replacing all missing value by value.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.varbyattrib","page":"NCDatasets.jl","title":"NCDatasets.varbyattrib","text":"varbyattrib(ds, attname = attval)\n\nReturns a list of variable(s) which has the attribute attname matching the value attval in the dataset ds. The list is empty if the none of the variables has the match. The output is a list of CFVariables.\n\nExamples\n\nLoad all the data of the first variable with standard name \"longitude\" from the NetCDF file results.nc.\n\njulia> ds = Dataset(\"results.nc\", \"r\");\njulia> data = varbyattrib(ds, standard_name = \"longitude\")[1][:]\n\n\n\n\n\n","category":"function"},{"location":"#Performance-tips-1","page":"NCDatasets.jl","title":"Performance tips","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Reading data from a file is not type-stable, because the type of the output of the read operation does depedent on the type defined in the NetCDF files and the value of various attribute (like scale_factor, add_offset and units for time conversion). All this information cannot be inferred from a static analysis of the source code. It is therefore recommended to use","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"type annotation if resulting type of a read operation in known:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"ds = Dataset(\"file.nc\")\ntemperature = ds[\"temperature\"][:] :: Array{Float64,2}\nclose(ds)","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Alternatively, one can also use so called \"[function barriers]\"(https://docs.julialang.org/en/v1/manual/performance-tips/index.html#kernel-functions-1) or the in-place load! function:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"ds = Dataset(\"file.nc\")\n\ntemperature = zeros(10,20)\nload!(ds[\"temperature\"],temperature,:,:)","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Most julia functions (like mean, sum,... from the module Statistics) access an array element-wise. It is generally much faster to load the data in memory (if possible) to make the computation.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"using NCDatasets, BenchmarkTools, Statistics\nds = Dataset(\"file.nc\",\"c\")\ndata = randn(100,100);\ndefVar(ds,\"myvar\",data,(\"lon\",\"lat\"))\nclose(ds)\n\nds = Dataset(\"file.nc\")\n@btime mean(ds[\"myvar\"]) # takes 107.357 ms\n@btime mean(ds[\"myvar\"][:]) # takes 106.873 Î¼s, 1000 times faster\nclose(ds)","category":"page"},{"location":"#Multi-file-support-(experimental)-1","page":"NCDatasets.jl","title":"Multi-file support (experimental)","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Multiple files can also be aggregated over a given dimensions (or the record dimension). In this example, 3 sea surface temperature fields from the 1992-01-01 to 1992-01-03 are aggregated using the OpenDAP service from PODAAC.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"using NCDatasets, Printf, Dates\n\nfunction url(dt)\n  doy = @sprintf(\"%03d\",Dates.dayofyear(dt))\n  y = @sprintf(\"%04d\",Dates.year(dt))\n  yyyymmdd = Dates.format(dt,\"yyyymmdd\")\n  return \"https://podaac-opendap.jpl.nasa.gov:443/opendap/allData/ghrsst/data/GDS2/L4/GLOB/CMC/CMC0.2deg/v2/$y/$doy/$(yyyymmdd)120000-CMC-L4_GHRSST-SSTfnd-CMC0.2deg-GLOB-v02.0-fv02.0.nc\"\nend\n\nds = Dataset(url.(DateTime(1992,1,1):Dates.Day(1):DateTime(1992,1,3)),aggdim = \"time\");\nSST2 = ds[\"analysed_sst\"][:,:,:];\nclose(ds)","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"If there is a network or server issue, you will see an error message like \"NetCDF: I/O failure\".","category":"page"},{"location":"#Experimental-functions-1","page":"NCDatasets.jl","title":"Experimental functions","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"NCDatasets.ancillaryvariables\nNCDatasets.filter","category":"page"},{"location":"#NCDatasets.ancillaryvariables","page":"NCDatasets.jl","title":"NCDatasets.ancillaryvariables","text":"ncvar = NCDatasets.ancillaryvariables(ncv::NCDatasets.CFVariable,modifier)\n\nReturn the first ancillary variables from the NetCDF variable ncv with the standard name modifier modifier. It can be used for example to access related variable like status flags.\n\n\n\n\n\n","category":"function"},{"location":"#NCDatasets.filter","page":"NCDatasets.jl","title":"NCDatasets.filter","text":"data = NCDatasets.filter(ncv, indices...; accepted_status_flags = nothing)\n\nLoad and filter observations by replacing all variables without an acepted status flag to missing. It is used the attribute ancillary_variables to identify the status flag.\n\n# da[\"data\"] is 2D matrix\ngood_data = NCDatasets.filter(ds[\"data\"],:,:, accepted_status_flags = [\"good_data\",\"probably_good_data\"])\n\n\n\n\n\n","category":"function"},{"location":"#Issues-1","page":"NCDatasets.jl","title":"Issues","text":"","category":"section"},{"location":"#libnetcdf-not-properly-installed-1","page":"NCDatasets.jl","title":"libnetcdf not properly installed","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"If you see the following error,","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"ERROR: LoadError: LoadError: libnetcdf not properly installed. Please run Pkg.build(\"NCDatasets\")","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"you can try to install netcdf explicitly with Conda:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"using Conda\nConda.add(\"libnetcdf\")","category":"page"},{"location":"#NetCDF:-Not-a-valid-data-type-or-_FillValue-type-mismatch-1","page":"NCDatasets.jl","title":"NetCDF: Not a valid data type or _FillValue type mismatch","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"Trying to define the _FillValue, procudes the following error:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"ERROR: LoadError: NCDatasets.NetCDFError(-45, \"NetCDF: Not a valid data type or _FillValue type mismatch\")","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"The error could be generated by a code like this:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"using NCDatasets\n# ...\ntempvar = defVar(ds,\"temp\",Float32,(\"lonc\",\"latc\",\"time\"))\ntempvar.attrib[\"_FillValue\"] = -9999.","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"In fact, _FillValue must have the same data type as the corresponding variable. In the case above, tempvar is a 32-bit float and the number -9999. is a 64-bit float (aka double, which is the default floating point type in Julia). It is sufficient to convert the value -9999. to a 32-bit float:","category":"page"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"tempvar.attrib[\"_FillValue\"] = Float32(-9999.) # or\ntempvar.attrib[\"_FillValue\"] = -9999.f0","category":"page"},{"location":"#Corner-cases-1","page":"NCDatasets.jl","title":"Corner cases","text":"","category":"section"},{"location":"#","page":"NCDatasets.jl","title":"NCDatasets.jl","text":"An attribute representing a vector with a single value (e.g. [1]) will be read back as a scalar (1) (same behavior in python netCDF4 1.3.1).\nNetCDF and Julia distinguishes between a vector of chars and a string, but both are returned as string for ease of use, in particular an attribute representing a vector of chars ['u','n','i','t','s'] will be read back as the string \"units\".\nAn attribute representing a vector of chars ['u','n','i','t','s','\\0'] will also be read back as the string \"units\" (issue #12).","category":"page"}]
}
