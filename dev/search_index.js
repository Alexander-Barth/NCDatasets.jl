var documenterSearchIndex = {"docs":
[{"location":"dataset/#Datasets-1","page":"Datasets","title":"Datasets","text":"","category":"section"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"This page is about loading/writing, examining and operating directly on entire NetCDF datasets. For functions regarding the variables stored in them, see the Variables page.","category":"page"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"Both variables and datasets share the functionality of the Attributes section.","category":"page"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"NCDataset","category":"page"},{"location":"dataset/#NCDatasets.NCDataset","page":"Datasets","title":"NCDatasets.NCDataset","text":"NCDataset(filename::AbstractString, mode = \"r\";\n        format::Symbol = :netcdf4, attrib = [])\n\nLoad, create, or even overwrite a NetCDF file at filename, depending on mode:\n\n\"r\" (default) : open an existing netCDF file or OPeNDAP URL  in read-only mode.\n\"c\" : create a new NetCDF file at filename (an existing file with the same name will be overwritten).\n\"a\" : open filename into append mode (i.e. existing data in the netCDF file is not overwritten and a variable can be added).\n\nNotice that this does not close the dataset, use close on the result (or see below the do-block).\n\nThe optional parameter attrib is an iterable of attribute name and attribute value pairs, for example a Dict, DataStructures.OrderedDict or simply a vector of pairs (see example below).\n\nSupported format values:\n\n:netcdf4 (default): HDF5-based NetCDF format.\n:netcdf4_classic: Only netCDF 3 compatible API features will be used.\n:netcdf3_classic: classic netCDF format supporting only files smaller than 2GB.\n:netcdf3_64bit_offset: improved netCDF format supporting files larger than 2GB.\n\nFiles can also be open and automatically closed with a do block.\n\nNCDataset(\"file.nc\") do ds\n    data = ds[\"temperature\"][:,:]\nend\n\nHere is an attribute example:\n\nusing DataStructures\nNCDataset(\"file.nc\", \"c\", attrib = OrderedDict(\"title\" => \"my first netCDF file\")) do ds\n   defVar(ds,\"temp\",[10.,20.,30.],(\"time\",))\nend;\n\nNCDataset is an alias to NCDataset.\n\n\n\n\n\nds = NCDataset(var::CFVariable)\nds = NCDataset(var::Variable)\n\nReturn the NCDataset containing the variable var.\n\n\n\n\n\nmfds = NCDataset(fnames,mode = \"r\"; aggdim = nothing, deferopen = true)\n\nOpens a multi-file dataset in read-only \"r\" or append mode \"a\". fnames is a vector of file names. Variables are aggregated over the first unlimited dimension or over the dimension aggdim if specified. The append mode is only implemented when deferopen is false.\n\nAll variables containing the dimension aggdim are aggregated. The variable who do not contain the dimension aggdim are assumed constant.\n\nIf deferopen is false, all files are opened at the same time. However the operating system might limit the number of open files. In Linux, the limit can be controled with the command ulimit.\n\n\n\n\n\n","category":"type"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"Useful functions that operate on datasets are:","category":"page"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"keys(ds::NCDataset)\nhaskey\ngetindex(ds::NCDataset,varname::AbstractString)\nvariable\nsync\nclose\npath\nncgen\nvarbyattrib\nwrite(::AbstractString, ::NCDataset)","category":"page"},{"location":"dataset/#Base.keys-Tuple{NCDataset}","page":"Datasets","title":"Base.keys","text":"keys(ds::NCDataset)\n\nReturn a list of all variables names in NCDataset ds.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#Base.haskey","page":"Datasets","title":"Base.haskey","text":"haskey(ds::NCDataset,name)\nhaskey(d::Dimensions,name)\nhaskey(ds::Attributes,name)\n\nReturn true if the NCDataset ds (or dimension/attribute list) has a variable (dimension/attribute) with the name name. For example:\n\nds = NCDataset(\"/tmp/test.nc\",\"r\")\nif haskey(ds,\"temperature\")\n    println(\"The file has a variable 'temperature'\")\nend\n\nif haskey(ds.dim,\"lon\")\n    println(\"The file has a dimension 'lon'\")\nend\n\nThis example checks if the file /tmp/test.nc has a variable with the name temperature and a dimension with the name lon.\n\n\n\n\n\n","category":"function"},{"location":"dataset/#Base.getindex-Tuple{NCDataset,AbstractString}","page":"Datasets","title":"Base.getindex","text":"v = getindex(ds::NCDataset,varname::AbstractString)\n\nReturn the NetCDF variable varname in the dataset ds as a NCDataset.CFVariable. The CF convention are honored when the variable is indexed:\n\n_FillValue will be returned as missing\nscale_factor and add_offset are applied\ntime variables (recognized by the units attribute) are returned usually as DateTime object. Note that DateTimeAllLeap, DateTimeNoLeap and DateTime360Day cannot be converted to the proleptic gregorian calendar used in julia and are returned as such.\n\nA call getindex(ds,varname) is usually written as ds[varname].\n\n\n\n\n\n","category":"method"},{"location":"dataset/#NCDatasets.variable","page":"Datasets","title":"NCDatasets.variable","text":"v = variable(ds::NCDataset,varname::String)\n\nReturn the NetCDF variable varname in the dataset ds as a NCDataset.Variable. No scaling or other transformations are applied when the variable v is indexed.\n\n\n\n\n\n","category":"function"},{"location":"dataset/#NCDatasets.sync","page":"Datasets","title":"NCDatasets.sync","text":"sync(ds::NCDataset)\n\nWrite all changes in NCDataset ds to the disk.\n\n\n\n\n\n","category":"function"},{"location":"dataset/#Base.close","page":"Datasets","title":"Base.close","text":"close(ds::NCDataset)\n\nClose the NCDataset ds. All pending changes will be written to the disk.\n\n\n\n\n\n","category":"function"},{"location":"dataset/#NCDatasets.path","page":"Datasets","title":"NCDatasets.path","text":"path(ds::NCDataset)\n\nReturn the file path (or the opendap URL) of the NCDataset ds\n\n\n\n\n\n","category":"function"},{"location":"dataset/#NCDatasets.ncgen","page":"Datasets","title":"NCDatasets.ncgen","text":"ncgen(fname; ...)\nncgen(fname,jlname; ...)\n\nGenerate the Julia code that would produce a NetCDF file with the same metadata as the NetCDF file fname. The code is placed in the file jlname or printed to the standard output. By default the new NetCDF file is called filename.nc. This can be changed with the optional parameter newfname.\n\n\n\n\n\n","category":"function"},{"location":"dataset/#NCDatasets.varbyattrib","page":"Datasets","title":"NCDatasets.varbyattrib","text":"varbyattrib(ds, attname = attval)\n\nReturns a list of variable(s) which has the attribute attname matching the value attval in the dataset ds. The list is empty if the none of the variables has the match. The output is a list of CFVariables.\n\nExamples\n\nLoad all the data of the first variable with standard name \"longitude\" from the NetCDF file results.nc.\n\njulia> ds = NCDataset(\"results.nc\", \"r\");\njulia> data = varbyattrib(ds, standard_name = \"longitude\")[1][:]\n\n\n\n\n\n","category":"function"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"Notice that DateTime-structures from CFTime are used to represent time for non-standard calendars. Otherwise, we attempt to use standard structures from the Julia standard library Dates.","category":"page"},{"location":"dataset/#Groups-1","page":"Datasets","title":"Groups","text":"","category":"section"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"defGroup(ds::NCDataset,groupname)\ngetindex(g::NCDatasets.Groups,groupname::AbstractString)\nBase.keys(g::NCDatasets.Groups)\n    groupname(ds::NCDataset)","category":"page"},{"location":"dataset/#NCDatasets.defGroup-Tuple{NCDataset,Any}","page":"Datasets","title":"NCDatasets.defGroup","text":"defGroup(ds::NCDataset,groupname, attrib = []))\n\nCreate the group with the name groupname in the dataset ds. attrib is a list of attribute name and attribute value pairs (see NCDataset).\n\n\n\n\n\n","category":"method"},{"location":"dataset/#Base.getindex-Tuple{NCDatasets.Groups,AbstractString}","page":"Datasets","title":"Base.getindex","text":"group = getindex(g::NCDatasets.Groups,groupname::AbstractString)\n\nReturn the NetCDF group with the name groupname. For example:\n\njulia> ds = NCDataset(\"results.nc\", \"r\");\njulia> forecast_group = ds.group[\"forecast\"]\njulia> forecast_temp = forecast_group[\"temperature\"]\n\n\n\n\n\n","category":"method"},{"location":"dataset/#Base.keys-Tuple{NCDatasets.Groups}","page":"Datasets","title":"Base.keys","text":"Base.keys(g::NCDatasets.Groups)\n\nReturn the names of all subgroubs of the group g.\n\n\n\n\n\n","category":"method"},{"location":"dataset/#NCDatasets.groupname-Tuple{NCDataset}","page":"Datasets","title":"NCDatasets.groupname","text":"groupname(ds::NCDataset)\n\nReturn the group name of the NCDataset ds\n\n\n\n\n\n","category":"method"},{"location":"dataset/#Common-methods-1","page":"Datasets","title":"Common methods","text":"","category":"section"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"One can iterate over a dataset, attribute list, dimensions and NetCDF groups.","category":"page"},{"location":"dataset/#","page":"Datasets","title":"Datasets","text":"for (varname,var) in ds\n    # all variables\n    @show (varname,size(var))\nend\n\nfor (attribname,attrib) in ds.attrib\n    # all attributes\n    @show (attribname,attrib)\nend\n\nfor (groupname,group) in ds.groups\n    # all groups\n    @show (groupname,group)\nend","category":"page"},{"location":"performance/#Performance-tips-1","page":"Performance tips","title":"Performance tips","text":"","category":"section"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"Reading data from a file is not type-stable, because the type of the output of the read operation does depedent on the type defined in the NetCDF files and the value of various attribute (like scale_factor, add_offset and units for time conversion). All this information cannot be inferred from a static analysis of the source code. It is therefore recommended to use type annotation if resulting type of a read operation in known:","category":"page"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"ds = NCDataset(\"file.nc\")\nnctemp = ds[\"temp\"]\ntemp = nctemp[:,:] :: Array{Float64,2}\n# or\n# call_barrier_function(nctemp)\n# call_barrier_function(temp)\nclose(ds)","category":"page"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"Alternatively, one can also use so called \"function barriers\" or the in-place load! function:","category":"page"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"ds = NCDataset(\"file.nc\")\n\ntemp = zeros(10,20)\nload!(ds[\"temp\"],temp,:,:)","category":"page"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"Most julia functions (like mean, sum,... from the module Statistics) access an array element-wise. It is generally much faster to load the data in memory (if possible) to make the computation.","category":"page"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"using NCDatasets, BenchmarkTools, Statistics\nds = NCDataset(\"file.nc\",\"c\")\ndata = randn(100,100);\ndefVar(ds,\"myvar\",data,(\"lon\",\"lat\"))\nclose(ds)\n\nds = NCDataset(\"file.nc\")\n@btime mean(ds[\"myvar\"]) # takes 107.357 ms\n@btime mean(ds[\"myvar\"][:,:]) # takes 106.873 μs, 1000 times faster\nclose(ds)","category":"page"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"Avoid when possible indexing with arrays and CartesianIndex as they also result in loading the data element-wise.","category":"page"},{"location":"performance/#","page":"Performance tips","title":"Performance tips","text":"ds = NCDataset(\"dataset.nc\");\nv = ds[\"v1\"][:,[1,2,3],:]; # slow\nv = ds[\"v1\"][:,1:3,:]; # fast\nv = ds[\"v1\"][:,:,CartesianIndex(1)] # slow\nv = ds[\"v1\"][:,:,1] # fast\nclose(ds)","category":"page"},{"location":"experimental/#Experimental-features-1","page":"Experimental features","title":"Experimental features","text":"","category":"section"},{"location":"experimental/#Multi-file-support-1","page":"Experimental features","title":"Multi-file support","text":"","category":"section"},{"location":"experimental/#","page":"Experimental features","title":"Experimental features","text":"Multiple files can also be aggregated over a given dimensions (or the record dimension). In this example, 3 sea surface temperature fields from the 1992-01-01 to 1992-01-03 are aggregated using the OpenDAP service from PODAAC.","category":"page"},{"location":"experimental/#","page":"Experimental features","title":"Experimental features","text":"using NCDatasets, Printf, Dates\n\nfunction url(dt)\n  doy = @sprintf(\"%03d\",Dates.dayofyear(dt))\n  y = @sprintf(\"%04d\",Dates.year(dt))\n  yyyymmdd = Dates.format(dt,\"yyyymmdd\")\n  return \"https://podaac-opendap.jpl.nasa.gov:443/opendap/allData/ghrsst/data/GDS2/L4/GLOB/CMC/CMC0.2deg/v2/$y/$doy/$(yyyymmdd)120000-CMC-L4_GHRSST-SSTfnd-CMC0.2deg-GLOB-v02.0-fv02.0.nc\"\nend\n\nds = NCDataset(url.(DateTime(1992,1,1):Dates.Day(1):DateTime(1992,1,3)),aggdim = \"time\");\nSST2 = ds[\"analysed_sst\"][:,:,:];\nclose(ds)","category":"page"},{"location":"experimental/#","page":"Experimental features","title":"Experimental features","text":"If there is a network or server issue, you will see an error message like NetCDF: I/O failure.","category":"page"},{"location":"experimental/#Experimental-functions-1","page":"Experimental features","title":"Experimental functions","text":"","category":"section"},{"location":"experimental/#","page":"Experimental features","title":"Experimental features","text":"NCDatasets.ancillaryvariables\nNCDatasets.filter","category":"page"},{"location":"experimental/#NCDatasets.ancillaryvariables","page":"Experimental features","title":"NCDatasets.ancillaryvariables","text":"ncvar = NCDatasets.ancillaryvariables(ncv::NCDatasets.CFVariable,modifier)\n\nReturn the first ancillary variables from the NetCDF variable ncv with the standard name modifier modifier. It can be used for example to access related variable like status flags.\n\n\n\n\n\n","category":"function"},{"location":"experimental/#Base.filter","page":"Experimental features","title":"Base.filter","text":"data = NCDatasets.filter(ncv, indices...; accepted_status_flags = nothing)\n\nLoad and filter observations by replacing all variables without an acepted status flag to missing. It is used the attribute ancillary_variables to identify the status flag.\n\n# da[\"data\"] is 2D matrix\ngood_data = NCDatasets.filter(ds[\"data\"],:,:, accepted_status_flags = [\"good_data\",\"probably_good_data\"])\n\n\n\n\n\n","category":"function"},{"location":"variables/#Variables-1","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Variables (like e.g. CFVariable) are the quantities contained within a NetCDF dataset. See the Datasets page on how to obtain them from a dataset.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Different type of arrays are involved when working with NCDatasets. For instance assume that test.nc is a file with a Float32 variable called var. Assume that we open this data set in append mode (\"a\"):","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"using NCDatasets\nds = NCDataset(\"test.nc\",\"a\")\nv_cf = ds[\"var\"]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The variable v_cf has the type CFVariable. No data is actually loaded from disk, but you can query its size, number of dimensions, number elements, etc., using the functions size, ndims, length as if v_cf was an ordinary Julia array.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"To load the variable v_cf in memory as numeric data you can convert it into an array (preserving its dimensionality structure) with","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Array(v_cf)","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The syntax v_cf[:] is equivalent with the above, it doesn't make a Vector (like it does on normal Julia arrays).","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"You can only load sub-parts of it in memory via indexing each dimension:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"v_cf[1:5, 10:20]","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"(here you must know the number of dimensions of the variable, as you must access all of them).","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"note: Note\nNCDatasets.Variable and NCDatasets.CFVariable implement the interface of AbstractArray. It is thus possible to call any function that accepts an AbstractArray. But functions like mean, sum (and many more) would load every element individually which is very inefficient for large fields read from disk. You should instead convert such a variable to a standard Julia Array and then do computations with it. See also the performance tips for more information.","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"The following functions are convenient for working with variables:","category":"page"},{"location":"variables/#","page":"Variables","title":"Variables","text":"Base.size(v::NCDatasets.CFVariable)\ndimnames\ndimsize\nname\nrenameVar\nNCDataset(var::NCDatasets.CFVariable)\nnomissing\nfillvalue","category":"page"},{"location":"variables/#Base.size-Tuple{NCDatasets.CFVariable}","page":"Variables","title":"Base.size","text":"sz = size(var::CFVariable)\n\nReturn a tuple of integers with the size of the variable var.\n\nnote: Note\nNote that the size of a variable can change, i.e. for a variable with an unlimited dimension.\n\n\n\n\n\n","category":"method"},{"location":"variables/#NCDatasets.dimnames","page":"Variables","title":"NCDatasets.dimnames","text":"dimnames(v::Variable)\n\nReturn a tuple of strings with the dimension names of the variable v.\n\n\n\n\n\ndimnames(v::CFVariable)\n\nReturn a tuple of strings with the dimension names of the variable v.\n\n\n\n\n\n","category":"function"},{"location":"variables/#NCDatasets.dimsize","page":"Variables","title":"NCDatasets.dimsize","text":"dimsize(v::CFVariable)\n\nGet the size of a CFVariable as a named tuple of dimension → length.\n\n\n\n\n\n","category":"function"},{"location":"variables/#NCDatasets.name","page":"Variables","title":"NCDatasets.name","text":"name(v::Variable)\n\nReturn the name of the NetCDF variable v.\n\n\n\n\n\n","category":"function"},{"location":"variables/#NCDatasets.renameVar","page":"Variables","title":"NCDatasets.renameVar","text":"renameVar(ds::NCDataset,oldname,newname)\n\nRename the variable called oldname to newname.\n\n\n\n\n\n","category":"function"},{"location":"variables/#NCDatasets.NCDataset-Tuple{NCDatasets.CFVariable}","page":"Variables","title":"NCDatasets.NCDataset","text":"mfds = NCDataset(fnames,mode = \"r\"; aggdim = nothing, deferopen = true)\n\nOpens a multi-file dataset in read-only \"r\" or append mode \"a\". fnames is a vector of file names. Variables are aggregated over the first unlimited dimension or over the dimension aggdim if specified. The append mode is only implemented when deferopen is false.\n\nAll variables containing the dimension aggdim are aggregated. The variable who do not contain the dimension aggdim are assumed constant.\n\nIf deferopen is false, all files are opened at the same time. However the operating system might limit the number of open files. In Linux, the limit can be controled with the command ulimit.\n\n\n\n\n\n","category":"method"},{"location":"variables/#NCDatasets.nomissing","page":"Variables","title":"NCDatasets.nomissing","text":"a = nomissing(da)\n\nReturn the values of the array da of type Array{Union{T,Missing},N} (potentially containing missing values) as a regular Julia array a of the same element type. It raises an error if the array contains at least one missing value.\n\n\n\n\n\na = nomissing(da,value)\n\nRetun the values of the array da of type Array{Union{T,Missing},N} as a regular Julia array a by replacing all missing value by value (converted to type T). This function is identical to coalesce.(da,T(value)) where T is the element tyoe of da.\n\nExample:\n\njulia> nomissing([missing,1.,2.],NaN)\n# returns [NaN, 1.0, 2.0]\n\n\n\n\n\n","category":"function"},{"location":"variables/#NCDatasets.fillvalue","page":"Variables","title":"NCDatasets.fillvalue","text":"fillvalue(::Type{Int8})\nfillvalue(::Type{UInt8})\nfillvalue(::Type{Int16})\nfillvalue(::Type{UInt16})\nfillvalue(::Type{Int32})\nfillvalue(::Type{UInt32})\nfillvalue(::Type{Int64})\nfillvalue(::Type{UInt64})\nfillvalue(::Type{Float32})\nfillvalue(::Type{Float64})\nfillvalue(::Type{Char})\nfillvalue(::Type{String})\n\nDefault fill-value for the given type.\n\n\n\n\n\nfv = fillvalue(v::Variable)\nfv = fillvalue(v::CFVariable)\n\nReturn the fill-value of the variable v.\n\n\n\n\n\n","category":"function"},{"location":"variables/#","page":"Variables","title":"Variables","text":"loadragged\nNCDatasets.load!","category":"page"},{"location":"variables/#NCDatasets.loadragged","page":"Variables","title":"NCDatasets.loadragged","text":" data = loadragged(ncvar,index::Colon)\n\nLoad data from ncvar in the contiguous ragged array representation as a vector of vectors. It is typically used to load a list of profiles or time series of different length each.\n\nThe indexed ragged array representation is currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"variables/#NCDatasets.load!","page":"Variables","title":"NCDatasets.load!","text":"NCDatasets.load!(ncvar::Variable, data, indices)\n\nLoads a NetCDF variables ncvar in-place and puts the result in data along the specified indices.\n\nds = Dataset(\"file.nc\")\nncv = ds[\"vgos\"].var;\n# data must have the right shape and type\ndata = zeros(eltype(ncv),size(ncv));\nNCDatasets.load!(ncv,data,:,:,:)\nclose(ds)\n\n# loading a subset\ndata = zeros(5); # must have the right shape and type\nload!(ds[\"temp\"].var,data,:,1) # loads the 1st column\n\n\n\n\n\n","category":"function"},{"location":"variables/#Creating-a-variable-1","page":"Variables","title":"Creating a variable","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"defVar","category":"page"},{"location":"variables/#NCDatasets.defVar","page":"Variables","title":"NCDatasets.defVar","text":"defVar(ds::NCDataset,name,vtype,dimnames; kwargs...)\ndefVar(ds::NCDataset,name,data,dimnames; kwargs...)\n\nDefine a variable with the name name in the dataset ds.  vtype can be Julia types in the table below (with the corresponding NetCDF type). The parameter dimnames is a tuple with the names of the dimension.  For scalar this parameter is the empty tuple (). The variable is returned (of the type CFVariable).\n\nInstead of providing the variable type one can directly give also the data data which will be used to fill the NetCDF variable. In this case, the dimensions with the appropriate size will be created as required using the names in dimnames.\n\nIf data is a vector or array of DateTime objects, then the dates are saved as double-precision floats and units \"days since 1900-01-01 00:00:00\" (unless a time unit is specifed with the attrib keyword as described below). Dates are converted to the default calendar in the CF conversion which is the mixed Julian/Gregorian calendar.\n\nKeyword arguments\n\nfillvalue: A value filled in the NetCDF file to indicate missing data.  It will be stored in the _FillValue attribute.\nchunksizes: Vector integers setting the chunk size. The total size of a chunk must be less than 4 GiB.\ndeflatelevel: Compression level: 0 (default) means no compression and 9 means maximum compression. Each chunk will be compressed individually.\nshuffle: If true, the shuffle filter is activated which can improve the compression ratio.\nchecksum: The checksum method can be :fletcher32 or :nochecksum (checksumming is disabled, which is the default)\nattrib: An iterable of attribute name and attribute value pairs, for example a Dict, DataStructures.OrderedDict or simply a vector of pairs (see example below)\ntypename (string): The name of the NetCDF type required for vlen arrays\n\nchunksizes, deflatelevel, shuffle and checksum can only be set on NetCDF 4 files.\n\nNetCDF data types\n\nNetCDF Type Julia Type\nNC_BYTE Int8\nNC_UBYTE UInt8\nNC_SHORT Int16\nNC_INT Int32\nNC_INT64 Int64\nNC_FLOAT Float32\nNC_DOUBLE Float64\nNC_CHAR Char\nNC_STRING String\n\nExample:\n\nIn this example, scale_factor and add_offset are applied when the data is saved.\n\njulia> using DataStructures\njulia> data = randn(3,5)\njulia> NCDataset(\"test_file.nc\",\"c\") do ds\n          defVar(ds,\"temp\",data,(\"lon\",\"lat\"), attrib = OrderedDict(\n             \"units\" => \"degree_Celsius\",\n             \"add_offset\" => -273.15,\n             \"scale_factor\" => 0.1,\n             \"long_name\" => \"Temperature\"\n          ))\n       end;\n\nnote: Note\nIf the attributes _FillValue, add_offset, scale_factor, units and calendar are used, they should be defined when calling defVar by using the parameter attrib as shown in the example above.\n\n\n\n\n\n","category":"function"},{"location":"variables/#Storage-parameter-of-a-variable-1","page":"Variables","title":"Storage parameter of a variable","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"chunking\ndeflate\nchecksum","category":"page"},{"location":"variables/#NCDatasets.chunking","page":"Variables","title":"NCDatasets.chunking","text":"storage,chunksizes = chunking(v::Variable)\n\nReturn the storage type (:contiguous or :chunked) and the chunk sizes of the varable v.\n\n\n\n\n\n","category":"function"},{"location":"variables/#NCDatasets.deflate","page":"Variables","title":"NCDatasets.deflate","text":"isshuffled,isdeflated,deflate_level = deflate(v::Variable)\n\nReturn compression information of the variable v. If shuffle is true, then shuffling (byte interlacing) is activaded. If deflate is true, then the data chunks (see chunking) are compressed using the compression level deflate_level (0 means no compression and 9 means maximum compression).\n\n\n\n\n\n","category":"function"},{"location":"variables/#NCDatasets.checksum","page":"Variables","title":"NCDatasets.checksum","text":"checksummethod = checksum(v::Variable)\n\nReturn the checksum method of the variable v which can be either be :fletcher32 or :nochecksum.\n\n\n\n\n\n","category":"function"},{"location":"variables/#Coordinate-variables-1","page":"Variables","title":"Coordinate variables","text":"","category":"section"},{"location":"variables/#","page":"Variables","title":"Variables","text":"coord","category":"page"},{"location":"variables/#NCDatasets.coord","page":"Variables","title":"NCDatasets.coord","text":"cv = coord(v::Union{CFVariable,Variable},standard_name)\n\nFind the coordinate of the variable v by the standard name standard_name or some standardized heuristics based on units. If the heuristics fail to detect the coordinate, consider to modify the netCDF file to add the standard_name attribute. All dimensions of the coordinate must also be dimensions of the variable v.\n\nExample\n\nusing NCDatasets\nds = NCDataset(\"file.nc\")\nncv = ds[\"SST\"]\nlon = coord(ncv,\"longitude\")[:]\nlat = coord(ncv,\"latitude\")[:]\nv = ncv[:]\nclose(ds)\n\n\n\n\n\n","category":"function"},{"location":"issues/#Known-issues-1","page":"Known issues","title":"Known issues","text":"","category":"section"},{"location":"issues/#libnetcdf-not-properly-installed-1","page":"Known issues","title":"libnetcdf not properly installed","text":"","category":"section"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"If you see the following error,","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"ERROR: LoadError: LoadError: libnetcdf not properly installed. Please run Pkg.build(\"NCDatasets\")","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"you can try to install netcdf explicitly with Conda:","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"using Conda\nConda.add(\"libnetcdf\")","category":"page"},{"location":"issues/#NetCDF:-Not-a-valid-data-type-or-_FillValue-type-mismatch-1","page":"Known issues","title":"NetCDF: Not a valid data type or _FillValue type mismatch","text":"","category":"section"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"Trying to define the _FillValue, procudes the following error:","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"ERROR: LoadError: NCDatasets.NetCDFError(-45, \"NetCDF: Not a valid data type or _FillValue type mismatch\")","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"The error could be generated by a code like this:","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"using NCDatasets, DataStructures\n# ...\ntempvar = defVar(ds,\"temp\",Float32,(\"lonc\",\"latc\",\"time\"), attrib = OrderedDict(\n    \"_FillValue\" => -9999.))","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"or","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"using NCDatasets\n# ...\ntempvar = defVar(ds,\"temp\",Float32,(\"lonc\",\"latc\",\"time\"), fillvalue = -9999.)","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"In fact, _FillValue must have the same data type as the corresponding variable. In the case above, tempvar is a 32-bit float and the number -9999. is a 64-bit float (aka double, which is the default floating point type in Julia). It is sufficient to convert the value -9999. to a 32-bit float -9999.f0 (or Float32(-9999.)).","category":"page"},{"location":"issues/#Defining-the-attributes-_FillValue,-add_offset,-scale_factor,-units-and-calendar-1","page":"Known issues","title":"Defining the attributes _FillValue, add_offset, scale_factor, units and calendar","text":"","category":"section"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"An error like Cannotconvertan object of type Missing (or similar) is generated by code like this:","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"v = defVar(ds,\"var_with_all_missing_data\",Float32,(\"lon\",))\nv.attrib[\"_FillValue\"] = fv\nv[1] = missing","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"This produces the following error:","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"ERROR: LoadError: MethodError: Cannot `convert` an object of type Missing to an object of type Float32\nClosest candidates are:\n  convert(::Type{T}, ::T) where T<:Number at number.jl:6\n  convert(::Type{T}, ::Number) where T<:Number at number.jl:7\n  convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250\n  ...\nStacktrace:\n [1] fill!(::SubArray{Float32,1,NCDatasets.CFVariable{Float32,1,NCDatasets.Variable{Float32,1},NCDatasets.Attributes},Tuple{UnitRange{Int64}},false}, ::Missing) at ./multidimensional.jl:865\n [2] copyto! at ./broadcast.jl:871 [inlined]\n [3] materialize!(::SubArray{Float32,1,NCDatasets.CFVariable{Float32,1,NCDatasets.Variable{Float32,1},NCDatasets.Attributes},Tuple{UnitRange{Int64}},false}, ::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{0},Nothing,typeof(identity),Tuple{Base.RefValue{Missing}}}) at ./broadcast.jl:822","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"One should use define the _FillValue (and similar attributes like add_offset, scale_factor, units and calendar affecting the type of the data) in the call of defVar:","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"using DataStructures\nv = defVar(ds,\"var_with_all_missing_data\",Int32,(\"lon\",), fillvalue = fv, attrib = OrderedDict(\n    \"scale_factor\" => 0.1,\n    \"add_offset\" => 0.1\n    ))","category":"page"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"This change was introduced in NCDatasets version 0.10","category":"page"},{"location":"issues/#Mutiple-versions-of-HDF5-or-NetCDF-libraries-1","page":"Known issues","title":"Mutiple versions of HDF5 or NetCDF libraries","text":"","category":"section"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"Having outdated versions of HDF5 or NetCDF libraries installed can be an issue on Windows if they are included in the system PATH environement variable. It is advised to adapt the system PATH to remove the locations containing these libraries.","category":"page"},{"location":"issues/#Corner-cases-1","page":"Known issues","title":"Corner cases","text":"","category":"section"},{"location":"issues/#","page":"Known issues","title":"Known issues","text":"An attribute representing a vector with a single value (e.g. [1]) will be read back as a scalar (1) (same behavior in python netCDF4 1.3.1).\nNetCDF and Julia distinguishes between a vector of chars and a string, but both are returned as string for ease of use, in particular an attribute representing a vector of chars ['u','n','i','t','s'] will be read back as the string \"units\".\nAn attribute representing a vector of chars ['u','n','i','t','s','\\0'] will also be read back as the string \"units\" (issue #12).\nWhile reading a NetCDF time variable, the dates are converted using the Julia's DateTime (based on the proleptic Gregorian calendar following the ISO 8601 standard) when possible. When data is written to a NetCDF file (without specifying the calendar), the dates are saved using the default calendar of the NetCDF CF convention (the mixed Julian/Gregorian calendar, called \"standard\") when possible. It is recommended that the time origin specified by the units is after 15 October 1582 in which case the mixed Julian/Gregorian calendar is identical to the proleptic Gregorian calendar.","category":"page"},{"location":"attributes/#Attributes-1","page":"Attributes","title":"Attributes","text":"","category":"section"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"The NetCDF dataset (as returned by NCDataset or NetCDF groups) and the NetCDF variables (as returned by getindex, variable or defVar) have the field attrib which has the type NCDatasets.Attributes and behaves like a julia dictionary.","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"getindex(a::NCDatasets.Attributes,name::AbstractString)\nsetindex!(a::NCDatasets.Attributes,data,name::AbstractString)\nkeys(a::NCDatasets.Attributes)","category":"page"},{"location":"attributes/#Base.getindex-Tuple{NCDatasets.Attributes,AbstractString}","page":"Attributes","title":"Base.getindex","text":"getindex(a::Attributes,name::AbstractString)\n\nReturn the value of the attribute called name from the attribute list a. Generally the attributes are loaded by indexing, for example:\n\nds = NCDataset(\"file.nc\")\ntitle = ds.attrib[\"title\"]\n\n\n\n\n\n","category":"method"},{"location":"attributes/#Base.setindex!-Tuple{NCDatasets.Attributes,Any,AbstractString}","page":"Attributes","title":"Base.setindex!","text":"Base.setindex!(a::Attributes,data,name::AbstractString)\n\nSet the attribute called name to the value data in the attribute list a. Generally the attributes are defined by indexing, for example:\n\nds = NCDataset(\"file.nc\",\"c\")\nds.attrib[\"title\"] = \"my title\"\n\n\n\n\n\n","category":"method"},{"location":"attributes/#Base.keys-Tuple{NCDatasets.Attributes}","page":"Attributes","title":"Base.keys","text":"Base.keys(a::Attributes)\n\nReturn a list of the names of all attributes.\n\n\n\n\n\n","category":"method"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"Loading all attributes as a Dict can be achieved by passing ds.attrib (where ds is the NCDataset) as argument to Dict.","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"using NCDatasets\nncfile = download(\"https://www.unidata.ucar.edu/software/netcdf/examples/sresa1b_ncar_ccsm3-example.nc\");\nds = NCDataset(ncfile);\nattributes_as_dictionary = Dict(ds.attrib)\ntypeof(attributes_as_dictionary)\n# returns Dict{String,Any}","category":"page"},{"location":"attributes/#Possible-type-promotion-in-Julia-1","page":"Attributes","title":"Possible type promotion in Julia","text":"","category":"section"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"There is a subtile problem with the following code:","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"ncv1 = defVar(ds,\"v1\", UInt8, (\"longitude\", \"latitude\", \"time\"), attrib = [\n    \"add_offset\"                => -1.0,\n    \"scale_factor\"              => 5.0,\n    \"_FillValue\"                => UInt8(255),\n])","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"Julia effectively promotes the _FillValue to Float64 which leads to a \"NetCDF: Not a valid data type or _FillValue type mismatch\" as the fillvalue has to have exactly the same type as the NetCDF data type. Other parameters could be equally promoted.","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"[\n           \"add_offset\"                => -1.0,\n           \"scale_factor\"              => 5.0,\n           \"_FillValue\"                => UInt8(255),\n]\n# returns\n# 3-element Array{Pair{String,Float64},1}:\n#   \"add_offset\" => -1.0\n# \"scale_factor\" => 5.0\n#   \"_FillValue\" => 255.0","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"Note that the type of the second element of the Pair.","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"Using a Julia Dict does not show this behaviour:","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"ncv1 = defVar(ds,\"v1\", UInt8, (\"longitude\", \"latitude\", \"time\"), attrib = Dict(\n    \"add_offset\"                => -1.0,\n    \"scale_factor\"              => 5.0,\n    \"_FillValue\"                => UInt8(255),\n))","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"Note that Dict does not perserve the order of the attributes. Therefore an OrderedDict from the package DataStructures is preferable.","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"Or one could use simply the fillvalue parameter of defVar.","category":"page"},{"location":"attributes/#","page":"Attributes","title":"Attributes","text":"ncv1 = defVar(ds,\"v1\", UInt8, (\"longitude\", \"latitude\", \"time\"), fillvalue = UInt8(255), attrib = [\n    \"add_offset\"                => -1.0,\n    \"scale_factor\"              => 5.0,\n])","category":"page"},{"location":"dimensions/#Dimensions-1","page":"Dimensions","title":"Dimensions","text":"","category":"section"},{"location":"dimensions/#","page":"Dimensions","title":"Dimensions","text":"In the NetCDF data model, dimension have names and a length (but possibly an unlimited length) and are defined for a NetCDF dataset (or group). For a given Variable or CFVariable,the names of the corresponding dimensions are obtained with using dimnames.","category":"page"},{"location":"dimensions/#","page":"Dimensions","title":"Dimensions","text":"keys(d::NCDatasets.Dimensions)\nhaskey(a::NCDatasets.NCIterable,name::AbstractString)\ndefDim\nunlimited(d::NCDatasets.Dimensions)\nsetindex!(d::NCDatasets.Dimensions,len,name::AbstractString)","category":"page"},{"location":"dimensions/#Base.keys-Tuple{NCDatasets.Dimensions}","page":"Dimensions","title":"Base.keys","text":"keys(d::Dimensions)\n\nReturn a list of all dimension names in NCDataset ds.\n\nExamples\n\njulia> ds = NCDataset(\"results.nc\", \"r\");\njulia> dimnames = keys(ds.dim)\n\n\n\n\n\n","category":"method"},{"location":"dimensions/#Base.haskey-Tuple{Union{NCDatasets.AbstractDataset, NCDatasets.AbstractDimensions, NCDatasets.AbstractGroups, NCDatasets.BaseAttributes},AbstractString}","page":"Dimensions","title":"Base.haskey","text":"haskey(ds::NCDataset,name)\nhaskey(d::Dimensions,name)\nhaskey(ds::Attributes,name)\n\nReturn true if the NCDataset ds (or dimension/attribute list) has a variable (dimension/attribute) with the name name. For example:\n\nds = NCDataset(\"/tmp/test.nc\",\"r\")\nif haskey(ds,\"temperature\")\n    println(\"The file has a variable 'temperature'\")\nend\n\nif haskey(ds.dim,\"lon\")\n    println(\"The file has a dimension 'lon'\")\nend\n\nThis example checks if the file /tmp/test.nc has a variable with the name temperature and a dimension with the name lon.\n\n\n\n\n\n","category":"method"},{"location":"dimensions/#NCDatasets.defDim","page":"Dimensions","title":"NCDatasets.defDim","text":"defDim(ds::NCDataset,name,len)\n\nDefine a dimension in the data set ds with the given name and length len. If len is the special value Inf, then the dimension is considered as unlimited, i.e. it will grow as data is added to the NetCDF file.\n\nFor example:\n\nds = NCDataset(\"/tmp/test.nc\",\"c\")\ndefDim(ds,\"lon\",100)\n\nThis defines the dimension lon with the size 100.\n\n\n\n\n\n","category":"function"},{"location":"dimensions/#NCDatasets.unlimited-Tuple{NCDatasets.Dimensions}","page":"Dimensions","title":"NCDatasets.unlimited","text":"unlimited(d::Dimensions)\n\nReturn the names of all unlimited dimensions.\n\n\n\n\n\n","category":"method"},{"location":"dimensions/#Base.setindex!-Tuple{NCDatasets.Dimensions,Any,AbstractString}","page":"Dimensions","title":"Base.setindex!","text":"Base.setindex!(d::Dimensions,len,name::AbstractString)\n\nDefines the dimension called name to the length len. Generally dimension are defined by indexing, for example:\n\nds = NCDataset(\"file.nc\",\"c\")\nds.dim[\"longitude\"] = 100\n\nIf len is the special value Inf, then the dimension is considered as unlimited, i.e. it will grow as data is added to the NetCDF file.\n\n\n\n\n\n","category":"method"},{"location":"dimensions/#","page":"Dimensions","title":"Dimensions","text":"One can iterate over a list of dimensions as follows:","category":"page"},{"location":"dimensions/#","page":"Dimensions","title":"Dimensions","text":"for (dimname,dim) in ds.dims\n    # all dimensions\n    @show (dimname,dim)\nend","category":"page"},{"location":"#NCDatasets.jl-1","page":"Introduction","title":"NCDatasets.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Documentation for NCDatasets.jl, a Julia package for loading/writing NetCDF data, as well as doing basic numerics with them.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Inside the Julia shell, you can download and install using the following commands:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"NCDatasets\")","category":"page"},{"location":"#Latest-development-version-1","page":"Introduction","title":"Latest development version","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you want to try the latest development version, again go into package manager mode and simply type","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(PackageSpec(name=\"NCDatasets\", rev=\"master\"))","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"To get started quickly see the Quickstart section. Otherwise see the following pages for details:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Datasets : reading/writing NetCDF datasets (including NetCDF groups) and examining their contents.\nDimensions : accessing/creating NetCDF dimensions\nVariables : accessing/examining the variables (or dimensions) stored within a NetCDF dataset.\nAttributes : accessing/creating NetCDF attributes\nSee Performance tips, Known issues, Experimental features for more information.","category":"page"},{"location":"#Quickstart-1","page":"Introduction","title":"Quickstart","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This is a quickstart guide that outlines basic loading, reading, etc. usage. For more details please see the individual pages of the documentation.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Explore the content of a netCDF file\nLoad a netCDF file\nCreate a netCDF file\nEdit an existing netCDF file\nCreate a netCDF file using the metadata of an existing netCDF file as template\nGet one or several variables by specifying the value of an attribute\nLoad a file with unknown structure","category":"page"},{"location":"#Explore-the-content-of-a-netCDF-file-1","page":"Introduction","title":"Explore the content of a netCDF file","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Before reading the data from a netCDF file, it is often useful to explore the list of variables and attributes defined in it.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"For interactive use, the following commands (without ending semicolon) display the content of the file similarly to ncdump -h file.nc:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using NCDatasets\nds = NCDataset(\"file.nc\")","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This creates the central structure of NCDatasets.jl, NCDataset, which represents the contents of the netCDF file (without immediatelly loading everything in memory). NCDataset is an alias for NCDataset.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The following displays the information just for the variable varname:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"ds[\"varname\"]","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"while to get the global attributes you can do:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"ds.attrib","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"which produces a listing like:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"NCDataset: file.nc\nGroup: /\n\nDimensions\n   time = 115\n\nVariables\n  time   (115)\n    Datatype:    Float64\n    Dimensions:  time\n    Attributes:\n     calendar             = gregorian\n     standard_name        = time\n     units                = days since 1950-01-01 00:00:00\n[...]","category":"page"},{"location":"#Load-a-netCDF-file-1","page":"Introduction","title":"Load a netCDF file","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Loading a variable with known structure can be achieved by accessing the variables and attributes directly by their name.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# The mode \"r\" stands for read-only. The mode \"r\" is the default mode and the parameter can be omitted.\nds = NCDataset(\"/tmp/test.nc\",\"r\")\nv = ds[\"temperature\"]\n\n# load a subset\nsubdata = v[10:30,30:5:end]\n\n# load all data\ndata = v[:,:]\n\n# load all data ignoring attributes like scale_factor, add_offset, _FillValue and time units\ndata2 = v.var[:,:]\n\n\n# load an attribute\nunit = v.attrib[\"units\"]\nclose(ds)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"In the example above, the subset can also be loaded with:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"subdata = NCDataset(\"/tmp/test.nc\")[\"temperature\"][10:30,30:5:end]","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This might be useful in an interactive session. However, the file test.nc is not closed, which can be a problem if you open many files. On Linux the number of opened files is often limited to 1024 (soft limit). If you write to a file, you should also always close the file to make sure that the data is properly written to the disk.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"An alternative way to ensure the file has been closed is to use a do block: the file will be closed automatically when leaving the block.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"data =\nNCDataset(filename,\"r\") do ds\n    ds[\"temperature\"][:,:]\nend # ds is closed","category":"page"},{"location":"#Create-a-netCDF-file-1","page":"Introduction","title":"Create a netCDF file","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The following gives an example of how to create a netCDF file by defining dimensions, variables and attributes.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using NCDatasets\n# This creates a new NetCDF file /tmp/test.nc.\n# The mode \"c\" stands for creating a new file (clobber)\nds = NCDataset(\"/tmp/test.nc\",\"c\")\n\n# Define the dimension \"lon\" and \"lat\" with the size 100 and 110 resp.\ndefDim(ds,\"lon\",100)\ndefDim(ds,\"lat\",110)\n\n# Define a global attribute\nds.attrib[\"title\"] = \"this is a test file\"\n\n# Define the variables temperature\nv = defVar(ds,\"temperature\",Float32,(\"lon\",\"lat\"))\n\n# Generate some example data\ndata = [Float32(i+j) for i = 1:100, j = 1:110]\n\n# write a single column\nv[:,1] = data[:,1]\n\n# write a the complete data set\nv[:,:] = data\n\n# write attributes\nv.attrib[\"units\"] = \"degree Celsius\"\nv.attrib[\"comments\"] = \"this is a string attribute with Unicode Ω ∈ ∑ ∫ f(x) dx\"\n\nclose(ds)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"An equivalent way to create the previous netCDF would be the following code:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using NCDatasets\nusing DataStructures\ndata = [Float32(i+j) for i = 1:100, j = 1:110]\n\nDataset(\"/tmp/test2.nc\",\"c\",attrib = OrderedDict(\"title\" => \"this is a test file\")) do ds\n    # Define the variable temperature. The dimension \"lon\" and \"lat\" with the\n    # size 100 and 110 resp are implicetly created\n    defVar(ds,\"temperature\",data,(\"lon\",\"lat\"), attrib = OrderedDict(\n           \"units\" => \"degree Celsius\",\n           \"comments\" => \"this is a string attribute with Unicode Ω ∈ ∑ ∫ f(x) dx\"\n    ))\nend","category":"page"},{"location":"#Edit-an-existing-netCDF-file-1","page":"Introduction","title":"Edit an existing netCDF file","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"When you need to modify the variables or the attributes of a netCDF, you have to open it with the \"a\" option. Here of instance we add a global attribute creator to the file created in the previous step.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"ds = NCDataset(\"/tmp/test.nc\",\"a\")\nds.attrib[\"creator\"] = \"your name\"\nclose(ds);","category":"page"},{"location":"#Create-a-netCDF-file-using-the-metadata-of-an-existing-netCDF-file-as-template-1","page":"Introduction","title":"Create a netCDF file using the metadata of an existing netCDF file as template","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The utility function ncgen generates the Julia code that would produce a netCDF file with the same metadata as a template netCDF file. It is thus similar to the command line tool ncgen.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# download example file\nncfile = download(\"https://www.unidata.ucar.edu/software/netcdf/examples/sresa1b_ncar_ccsm3-example.nc\")\n# generate Julia code\nncgen(ncfile)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The produces the Julia code (only the beginning of the code is shown):","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"ds = NCDataset(\"filename.nc\",\"c\")\n# Dimensions\n\nds.dim[\"lat\"] = 128;\nds.dim[\"lon\"] = 256;\nds.dim[\"bnds\"] = 2;\nds.dim[\"plev\"] = 17;\nds.dim[\"time\"] = 1;\n\n# Declare variables\n\nncarea = defVar(ds,\"area\", Float32, (\"lon\", \"lat\"))\nncarea.attrib[\"long_name\"] = \"Surface area\";\nncarea.attrib[\"units\"] = \"meter2\";\n# ...","category":"page"},{"location":"#Get-one-or-several-variables-by-specifying-the-value-of-an-attribute-1","page":"Introduction","title":"Get one or several variables by specifying the value of an attribute","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The variable name are not always standardized, for example the longitude we can find: lon, LON, longitude, ...","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The solution implemented in the function varbyattrib consists in searching for the variables that have specified value for a given attribute.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"nclon = varbyattrib(ds, standard_name = \"longitude\");","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"will return the list of variables of the dataset ds that have \"longitude\" as standard name. To directly load the data of the first variable with the attribute standard_name equal to \"longitude\" one can the following:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"data = varbyattrib(ds, standard_name = \"longitude\")[1][:]","category":"page"},{"location":"#Load-a-file-with-unknown-structure-1","page":"Introduction","title":"Load a file with unknown structure","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If the structure of the netCDF file is not known before-hand, the program must check if a variable or attribute exists (with the haskey function) before loading it or alternatively place the loading in a try-catch block. It is also possible to iterate over all variables or attributes (global attributes or variable attributes) in the same syntax as iterating over a dictionary. However, unlike Julia dictionaries, the order of the attributes and variables is preserved and presented as they are stored in the netCDF file.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"# Open a file as read-only\nds = NCDataset(\"/tmp/test.nc\",\"r\")\n\n# check if a file has a variable with a given name\nif haskey(ds,\"temperature\")\n    println(\"The file has a variable 'temperature'\")\nend\n\n# get a list of all variable names\n@show keys(ds)\n\n# iterate over all variables\nfor (varname,var) in ds\n    @show (varname,size(var))\nend\n\n# query size of a variable (without loading it)\nv = ds[\"temperature\"]\n@show size(v)\n\n# similar for global and variable attributes\n\nif haskey(ds.attrib,\"title\")\n    println(\"The file has the global attribute 'title'\")\nend\n\n# get an list of all attribute names\n@show keys(ds.attrib)\n\n# iterate over all attributes\nfor (attname,attval) in ds.attrib\n    @show (attname,attval)\nend\n\n# get the attribute \"units\" of the variable v\n# but return the default value (here \"adimensional\")\n# if the attribute does not exists\n\nunits = get(v,\"units\",\"adimensional\")\nclose(ds)","category":"page"}]
}
