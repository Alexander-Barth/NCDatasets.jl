<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NCDatasets.jl · NCDatasets</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NCDatasets</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>NCDatasets.jl</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Tutorial-1">Tutorial</a></li><li><a class="toctext" href="#Datasets-1">Datasets</a></li><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Attributes-1">Attributes</a></li><li><a class="toctext" href="#Dimensions-1">Dimensions</a></li><li><a class="toctext" href="#Groups-1">Groups</a></li><li><a class="toctext" href="#Common-methods-1">Common methods</a></li><li class="toplevel"><a class="toctext" href="#Time-functions-1">Time functions</a></li><li class="toplevel"><a class="toctext" href="#Utility-functions-1">Utility functions</a></li><li class="toplevel"><a class="toctext" href="#Multi-file-support-(experimental)-1">Multi-file support (experimental)</a></li><li class="toplevel"><a class="toctext" href="#Experimental-functions-1">Experimental functions</a></li><li class="toplevel"><a class="toctext" href="#Issues-1">Issues</a></li><li><a class="toctext" href="#libnetcdf-not-properly-installed-1">libnetcdf not properly installed</a></li><li><a class="toctext" href="#NetCDF:-Not-a-valid-data-type-or-_FillValue-type-mismatch-1">NetCDF: Not a valid data type or _FillValue type mismatch</a></li><li><a class="toctext" href="#Corner-cases-1">Corner cases</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>NCDatasets.jl</a></li></ul><a class="edit-page" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>NCDatasets.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NCDatasets.jl-1" href="#NCDatasets.jl-1">NCDatasets.jl</a></h1><p>Documentation for NCDatasets.jl</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>Inside the Julia shell, you can download and install the package by issuing:</p><pre><code class="language-julia">using Pkg
Pkg.add(&quot;NCDatasets&quot;)</code></pre><h3><a class="nav-anchor" id="Latest-development-version-1" href="#Latest-development-version-1">Latest development version</a></h3><p>If you want to try the latest development version, you can do this with the following commands:</p><pre><code class="language-julia">using Pkg
Pkg.add(PackageSpec(url=&quot;https://github.com/Alexander-Barth/NCDatasets.jl&quot;, rev=&quot;master&quot;))
Pkg.build(&quot;NCDatasets&quot;)</code></pre><h2><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h2><h3><a class="nav-anchor" id="Create-a-netCDF-file-using-the-metadata-of-an-existing-netCDF-file-as-template-1" href="#Create-a-netCDF-file-using-the-metadata-of-an-existing-netCDF-file-as-template-1">Create a netCDF file using the metadata of an existing netCDF file as template</a></h3><p>The utility function <a href="https://alexander-barth.github.io/NCDatasets.jl/stable/#NCDatasets.ncgen"><code>ncgen</code></a> generates the Julia code that would produce a netCDF file with the same metadata as a template netCDF file. It is thus similar to the <a href="https://www.unidata.ucar.edu/software/netcdf/netcdf/ncgen.html">command line tool <code>ncgen</code></a>.</p><pre><code class="language-julia"># download example file
ncfile = download(&quot;https://www.unidata.ucar.edu/software/netcdf/examples/sresa1b_ncar_ccsm3-example.nc&quot;)
# generate Julia code
ncgen(ncfile)</code></pre><p>The produces the Julia code (only the beginning of the code is shown):</p><pre><code class="language-julia">ds = Dataset(&quot;filename.nc&quot;,&quot;c&quot;)
# Dimensions

ds.dim[&quot;lat&quot;] = 128;
ds.dim[&quot;lon&quot;] = 256;
ds.dim[&quot;bnds&quot;] = 2;
ds.dim[&quot;plev&quot;] = 17;
ds.dim[&quot;time&quot;] = 1;

# Declare variables

ncarea = defVar(ds,&quot;area&quot;, Float32, (&quot;lon&quot;, &quot;lat&quot;))
ncarea.attrib[&quot;long_name&quot;] = &quot;Surface area&quot;;
ncarea.attrib[&quot;units&quot;] = &quot;meter2&quot;;
# ...</code></pre><h3><a class="nav-anchor" id="Get-one-or-several-variables-by-specifying-the-value-of-an-attribute-1" href="#Get-one-or-several-variables-by-specifying-the-value-of-an-attribute-1">Get one or several variables by specifying the value of an attribute</a></h3><p>The variable name are not always standardized, for example the longitude we can find: <code>lon</code>, <code>LON</code>, <code>longitude</code>, ...</p><p>The solution implemented in the function <code>varbyattrib</code> consists in searching for the variables that have specified value for a given attribute.</p><pre><code class="language-julia">nclon = varbyattrib(ds, standard_name=&quot;longitude&quot;);</code></pre><p>will return the list of variables of the dataset <code>ds</code> that have &quot;longitude&quot; as standard name. To directly load the data of the first variable with the attribute <code>standard_name</code> equal to <code>&quot;longitude&quot;</code> one can the following:</p><pre><code class="language-julia">data = varbyattrib(ds, standard_name = &quot;longitude&quot;)[1][:]</code></pre><h3><a class="nav-anchor" id="Load-a-file-(with-unknown-structure)-1" href="#Load-a-file-(with-unknown-structure)-1">Load a file (with unknown structure)</a></h3><p>If the structure of the netCDF file is not known before-hand, the program must check if a variable or attribute exists (with the <code>haskey</code> function) before loading it or alternatively place the loading in a <code>try</code>-<code>catch</code> block. It is also possible to iterate over all variables or attributes (global attributes or variable attributes) in the same syntax as iterating over a dictionary. However, unlike Julia dictionaries, the order of the attributes and variables is preserved and presented as they are stored in the netCDF file.</p><pre><code class="language-julia"># Open a file as read-only
ds = Dataset(&quot;/tmp/test.nc&quot;,&quot;r&quot;)

# check if a file has a variable with a given name
if haskey(ds,&quot;temperature&quot;)
    println(&quot;The file has a variable &#39;temperature&#39;&quot;)
end

# get a list of all variable names
@show keys(ds)

# iterate over all variables
for (varname,var) in ds
    @show (varname,size(var))
end

# query size of a variable (without loading it)
v = ds[&quot;temperature&quot;]
@show size(v)

# similar for global and variable attributes

if haskey(ds.attrib,&quot;title&quot;)
    println(&quot;The file has the global attribute &#39;title&#39;&quot;)
end

# get an list of all attribute names
@show keys(ds.attrib)

# iterate over all attributes
for (attname,attval) in ds.attrib
    @show (attname,attval)
end

# get the attribute &quot;units&quot; of the variable v
# but return the default value (here &quot;adimensional&quot;)
# if the attribute does not exists

units = get(v,&quot;units&quot;,&quot;adimensional&quot;)
close(ds)</code></pre><h2><a class="nav-anchor" id="Datasets-1" href="#Datasets-1">Datasets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.Dataset" href="#NCDatasets.Dataset"><code>NCDatasets.Dataset</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Dataset(filename::AbstractString,mode::AbstractString = &quot;r&quot;;
                 format::Symbol = :netcdf4, attrib = [])</code></pre><p>Create a new NetCDF file if the <code>mode</code> is <code>&quot;c&quot;</code>. An existing file with the same name will be overwritten. If <code>mode</code> is <code>&quot;a&quot;</code>, then an existing file is open into append mode (i.e. existing data in the netCDF file is not overwritten and a variable can be added). With the mode set to <code>&quot;r&quot;</code>, an existing netCDF file or OPeNDAP URL can be open in read-only mode.  The default mode is <code>&quot;r&quot;</code>. The optional parameter <code>attrib</code> is an iterable of attribute name and attribute value pairs, for example a <code>Dict</code>, <code>DataStructures.OrderedDict</code> or simply a vector of pairs (see example below).</p><p><strong>Supported formats:</strong></p><ul><li><code>:netcdf4</code> (default): HDF5-based NetCDF format.</li><li><code>:netcdf4_classic</code>: Only netCDF 3 compatible API features will be used.</li><li><code>:netcdf3_classic</code>: classic netCDF format supporting only files smaller than 2GB.</li><li><code>:netcdf3_64bit_offset</code>: improved netCDF format supporting files larger than 2GB.</li></ul><p>Files can also be open and automatically closed with a <code>do</code> block.</p><pre><code class="language-julia">Dataset(&quot;file.nc&quot;) do ds
    data = ds[&quot;temperature&quot;][:,:]
end</code></pre><pre><code class="language-julia">Dataset(&quot;file.nc&quot;, &quot;c&quot;, attrib = [&quot;title&quot; =&gt; &quot;my first netCDF file&quot;]) do ds
   defVar(ds,&quot;temp&quot;,[10.,20.,30.],(&quot;time&quot;,))
end;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L443-L477">source</a><div><div><pre><code class="language-none">mfds = Dataset(fnames,mode = &quot;r&quot;; aggdim = nothing, deferopen = true)</code></pre><p>Opens a multi-file dataset in read-only &quot;r&quot; or append mode &quot;a&quot;. <code>fnames</code> is a vector of file names. Variables are aggregated over the first unlimited dimension or over the dimension <code>aggdim</code> if specified. The append mode is only implemented when <code>deferopen</code> is <code>false</code>.</p><p>All variables containing the dimension <code>aggdim</code> are aggregated. The variable who do not contain the dimension <code>aggdim</code> are assumed constant.</p><p>If deferopen is <code>false</code>, all files are opened at the same time. However the operating system might limit the number of open files. In Linux, the limit can be controled with the command <code>ulimit</code> [1,2].</p><p>[1]: https://stackoverflow.com/questions/34588/how-do-i-change-the-number-of-open-files-limit-in-linux [2]: https://unix.stackexchange.com/questions/8945/how-can-i-increase-open-files-limit-for-all-processes/8949#8949</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/multifile.jl#L3-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys-Tuple{Dataset}" href="#Base.keys-Tuple{Dataset}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">keys(ds::Dataset)</code></pre><p>Return a list of all variables names in Dataset <code>ds</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L691-L695">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.haskey" href="#Base.haskey"><code>Base.haskey</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">haskey(ds::Dataset,varname)</code></pre><p>Return true if the Dataset <code>ds</code> has a variable with the name <code>varname</code>. For example:</p><pre><code class="language-julia">ds = Dataset(&quot;/tmp/test.nc&quot;,&quot;r&quot;)
if haskey(ds,&quot;temperature&quot;)
    println(&quot;The file has a variable &#39;temperature&#39;&quot;)
end</code></pre><p>This example checks if the file <code>/tmp/test.nc</code> has a variable with the name <code>temperature</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L1414-L1429">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{Dataset,AbstractString}" href="#Base.getindex-Tuple{Dataset,AbstractString}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">v = getindex(ds::Dataset,varname::AbstractString)</code></pre><p>Return the NetCDF variable <code>varname</code> in the dataset <code>ds</code> as a <code>NCDataset.CFVariable</code>. The CF convention are honored when the variable is indexed:</p><ul><li><code>_FillValue</code> will be returned as <code>missing</code></li><li><code>scale_factor</code> and <code>add_offset</code> are applied</li><li>time variables (recognized by the units attribute) are returned as <code>DateTime</code> object.</li></ul><p>A call <code>getindex(ds,varname)</code> is usually written as <code>ds[varname]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L818-L829">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.variable" href="#NCDatasets.variable"><code>NCDatasets.variable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">v = variable(ds::Dataset,varname::String)</code></pre><p>Return the NetCDF variable <code>varname</code> in the dataset <code>ds</code> as a <code>NCDataset.Variable</code>. No scaling or other transformations are applied when the variable <code>v</code> is indexed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L730-L736">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.sync" href="#NCDatasets.sync"><code>NCDatasets.sync</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sync(ds::Dataset)</code></pre><p>Write all changes in Dataset <code>ds</code> to the disk.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L712-L716">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.close" href="#Base.close"><code>Base.close</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">close(ds::Dataset)</code></pre><p>Close the Dataset <code>ds</code>. All pending changes will be written to the disk.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L722-L727">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.path" href="#NCDatasets.path"><code>NCDatasets.path</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">path(ds::Dataset)</code></pre><p>Return the file path (or the opendap URL) of the Dataset <code>ds</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L698-L701">source</a></section><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.defVar" href="#NCDatasets.defVar"><code>NCDatasets.defVar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">defVar(ds::Dataset,name,vtype,dimnames; kwargs...)
defVar(ds::Dataset,name,data,dimnames; kwargs...)</code></pre><p>Define a variable with the name <code>name</code> in the dataset <code>ds</code>.  <code>vtype</code> can be Julia types in the table below (with the corresponding NetCDF type). Instead of providing the variable type one can directly give also the data <code>data</code> which will be used to fill the NetCDF variable. The parameter <code>dimnames</code> is a tuple with the names of the dimension.  For scalar this parameter is the empty tuple <code>()</code>. The variable is returned (of the type CFVariable).</p><p>Note if <code>data</code> is a vector or array of <code>DateTime</code> objects, then the dates are saved as double-precision floats and units &quot;days since 1900-01-01 00:00:00&quot; (unless a time unit is specifed with the <code>attrib</code> keyword described below)</p><p><strong>Keyword arguments</strong></p><ul><li><code>fillvalue</code>: A value filled in the NetCDF file to indicate missing data.  It will be stored in the _FillValue attribute.</li><li><code>chunksizes</code>: Vector integers setting the chunk size. The total size of a chunk must be less than 4 GiB.</li><li><code>deflatelevel</code>: Compression level: 0 (default) means no compression and 9 means maximum compression. Each chunk will be compressed individually.</li><li><code>shuffle</code>: If true, the shuffle filter is activated which can improve the compression ratio.</li><li><code>checksum</code>: The checksum method can be <code>:fletcher32</code> or <code>:nochecksum</code> (checksumming is disabled, which is the default)</li><li><code>attrib</code>: An iterable of attribute name and attribute value pairs, for example a <code>Dict</code>, <code>DataStructures.OrderedDict</code> or simply a vector of pairs (see example below)</li><li><code>typename</code> (string): The name of the NetCDF type required for vlen arrays [1]</li></ul><p><code>chunksizes</code>, <code>deflatelevel</code>, <code>shuffle</code> and <code>checksum</code> can only be set on NetCDF 4 files.</p><p><strong>NetCDF data types</strong></p><table><tr><th style="text-align: right">NetCDF Type</th><th style="text-align: right">Julia Type</th></tr><tr><td style="text-align: right">NC_BYTE</td><td style="text-align: right">Int8</td></tr><tr><td style="text-align: right">NC_UBYTE</td><td style="text-align: right">UInt8</td></tr><tr><td style="text-align: right">NC_SHORT</td><td style="text-align: right">Int16</td></tr><tr><td style="text-align: right">NC_INT</td><td style="text-align: right">Int32</td></tr><tr><td style="text-align: right">NC_INT64</td><td style="text-align: right">Int64</td></tr><tr><td style="text-align: right">NC_FLOAT</td><td style="text-align: right">Float32</td></tr><tr><td style="text-align: right">NC_DOUBLE</td><td style="text-align: right">Float64</td></tr><tr><td style="text-align: right">NC_CHAR</td><td style="text-align: right">Char</td></tr><tr><td style="text-align: right">NC_STRING</td><td style="text-align: right">String</td></tr></table><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; data = randn(3,5)
julia&gt; Dataset(&quot;test_file.nc&quot;,&quot;c&quot;) do ds
          defVar(ds,&quot;temp&quot;,data,(&quot;lon&quot;,&quot;lat&quot;), attrib = [
             &quot;units&quot; =&gt; &quot;degree_Celsius&quot;,
             &quot;long_name&quot; =&gt; &quot;Temperature&quot;
          ])
       end;
</code></pre><p>[1]: https://web.archive.org/save/https://www.unidata.ucar.edu/software/netcdf/netcdf-4/newdocs/netcdf-c/nc<em>005fdef</em>005fvlen.html</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L557-L615">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.dimnames" href="#NCDatasets.dimnames"><code>NCDatasets.dimnames</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dimnames(v::Variable)</code></pre><p>Return a tuple of the dimension names of the variable <code>v</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L876-L880">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.name" href="#NCDatasets.name"><code>NCDatasets.name</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">name(v::Variable)</code></pre><p>Return the name of the NetCDF variable <code>v</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L885-L889">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.chunking" href="#NCDatasets.chunking"><code>NCDatasets.chunking</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">storage,chunksizes = chunking(v::Variable)</code></pre><p>Return the storage type (<code>:contiguous</code> or <code>:chunked</code>) and the chunk sizes of the varable <code>v</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L894-L899">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.deflate" href="#NCDatasets.deflate"><code>NCDatasets.deflate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isshuffled,isdeflated,deflate_level = deflate(v::Variable)</code></pre><p>Return compression information of the variable <code>v</code>. If shuffle is <code>true</code>, then shuffling (byte interlacing) is activaded. If deflate is <code>true</code>, then the data chunks (see <code>chunking</code>) are compressed using the compression level <code>deflate_level</code> (0 means no compression and 9 means maximum compression).</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L905-L913">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.checksum" href="#NCDatasets.checksum"><code>NCDatasets.checksum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>checksummethod = checksum(v::Variable)</p><p>Return the checksum method of the variable <code>v</code> which can be either be <code>:fletcher32</code> or <code>:nochecksum</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L919-L924">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.loadragged" href="#NCDatasets.loadragged"><code>NCDatasets.loadragged</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia"> data = loadragged(ncvar,index::Colon)</code></pre><p>Load data from <code>ncvar</code> in the contiguous ragged array representation [1] as a vector of vectors. It is typically used to load a list of profiles or time series of different length each.</p><p>The indexed ragged array representation [2] is currently not supported.</p><p>[1]: https://web.archive.org/web/20190111092546/http://cfconventions.org/cf-conventions/v1.6.0/cf-conventions.html#<em>contiguous</em>ragged<em>array</em>representation [2]: https://web.archive.org/web/20190111092546/http://cfconventions.org/cf-conventions/v1.6.0/cf-conventions.html#<em>indexed</em>ragged<em>array</em>representation</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L1152-L1163">source</a></section><p>Different type of arrays are involved when working with NCDatasets. For instance assume that <code>test.nc</code> is a file with a <code>Float32</code> variable called <code>var</code>. Assume that we open this data set in append mode (<code>&quot;a&quot;</code>):</p><pre><code class="language-julia">using NCDatasets
ds = Dataset(&quot;test.nc&quot;,&quot;a&quot;)
v_cf = ds[&quot;var&quot;]</code></pre><p>The variable <code>v_cf</code> has the type <code>CFVariable</code>. No data is actually loaded from disk, but you can query its size, number of dimensions, number elements, ... by the functions <code>size</code>, <code>ndims</code>, <code>length</code> as ordinary Julia arrays. Once you index, the variable <code>v_cf</code>, then the data is loaded and stored into a <code>DataArray</code>:</p><pre><code class="language-julia">v_da = v_cf[:,:]</code></pre><h2><a class="nav-anchor" id="Attributes-1" href="#Attributes-1">Attributes</a></h2><p>The NetCDF dataset (as return by <code>Dataset</code> or NetCDF groups) and the NetCDF variables (as returned by <code>getindex</code>, <code>variable</code> or <code>defVar</code>) have the field <code>attrib</code> which has the type <code>NCDatasets.Attributes</code> and behaves like a julia dictionary.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{NCDatasets.Attributes,AbstractString}" href="#Base.getindex-Tuple{NCDatasets.Attributes,AbstractString}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getindex(a::Attributes,name::AbstractString)</code></pre><p>Return the value of the attribute called <code>name</code> from the attribute list <code>a</code>. Generally the attributes are loaded by indexing, for example:</p><pre><code class="language-julia">ds = Dataset(&quot;file.nc&quot;)
title = ds.attrib[&quot;title&quot;]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L244-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Tuple{NCDatasets.Attributes,Any,AbstractString}" href="#Base.setindex!-Tuple{NCDatasets.Attributes,Any,AbstractString}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Base.setindex!(a::Attributes,data,name::AbstractString)</code></pre><p>Set the attribute called <code>name</code> to the value <code>data</code> in the attribute list <code>a</code>. Generally the attributes are defined by indexing, for example:</p><pre><code class="language-julia">ds = Dataset(&quot;file.nc&quot;,&quot;c&quot;)
ds.attrib[&quot;title&quot;] = &quot;my title&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L261-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys-Tuple{NCDatasets.Attributes}" href="#Base.keys-Tuple{NCDatasets.Attributes}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Base.keys(a::Attributes)</p><p>Return a list of the names of all attributes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L278-L282">source</a></section><h2><a class="nav-anchor" id="Dimensions-1" href="#Dimensions-1">Dimensions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.defDim" href="#NCDatasets.defDim"><code>NCDatasets.defDim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">defDim(ds::Dataset,name,len)</code></pre><p>Define a dimension in the data set <code>ds</code> with the given <code>name</code> and length <code>len</code>. If <code>len</code> is the special value <code>Inf</code>, then the dimension is considered as <code>unlimited</code>, i.e. it will grow as data is added to the NetCDF file.</p><p>For example:</p><pre><code class="language-julia">ds = Dataset(&quot;/tmp/test.nc&quot;,&quot;c&quot;)
defDim(ds,&quot;lon&quot;,100)</code></pre><p>This defines the dimension <code>lon</code> with the size 100.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L538-L553">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Tuple{NCDatasets.Dimensions,Any,AbstractString}" href="#Base.setindex!-Tuple{NCDatasets.Dimensions,Any,AbstractString}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Base.setindex!(d::Dimensions,len,name::AbstractString)</code></pre><p>Defines the dimension called <code>name</code> to the length <code>len</code>. Generally dimension are defined by indexing, for example:</p><pre><code class="language-julia">ds = Dataset(&quot;file.nc&quot;,&quot;c&quot;)
ds.dim[&quot;longitude&quot;] = 100</code></pre><p>If <code>len</code> is the special value <code>Inf</code>, then the dimension is considered as <code>unlimited</code>, i.e. it will grow as data is added to the NetCDF file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L220-L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.dimnames-Tuple{NCDatasets.Variable}" href="#NCDatasets.dimnames-Tuple{NCDatasets.Variable}"><code>NCDatasets.dimnames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dimnames(v::Variable)</code></pre><p>Return a tuple of the dimension names of the variable <code>v</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L876-L880">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.unlimited-Tuple{NCDatasets.Dimensions}" href="#NCDatasets.unlimited-Tuple{NCDatasets.Dimensions}"><code>NCDatasets.unlimited</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unlimited(d::Dimensions)</code></pre><p>Return the names of all unlimited dimensions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L208-L212">source</a></section><h2><a class="nav-anchor" id="Groups-1" href="#Groups-1">Groups</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.defGroup-Tuple{Dataset,Any}" href="#NCDatasets.defGroup-Tuple{Dataset,Any}"><code>NCDatasets.defGroup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">defGroup(ds::Dataset,groupname, attrib = []))</code></pre><p>Create the group with the name <code>groupname</code> in the dataset <code>ds</code>. <code>attrib</code> is a list of attribute name and attribute value pairs (see <code>Dataset</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L419-L424">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{NCDatasets.Groups,AbstractString}" href="#Base.getindex-Tuple{NCDatasets.Groups,AbstractString}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">group = getindex(g::NCDatasets.Groups,groupname::AbstractString)</code></pre><p>Return the NetCDF <code>group</code> with the name <code>groupname</code>. For example:</p><pre><code class="language-julia-repl">julia&gt; ds = Dataset(&quot;results.nc&quot;, &quot;r&quot;);
julia&gt; forecast_group = ds.group[&quot;forecast&quot;]
julia&gt; forecast_temp = forecast_group[&quot;temperature&quot;]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L401-L413">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys-Tuple{NCDatasets.Groups}" href="#Base.keys-Tuple{NCDatasets.Groups}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Base.keys(g::NCDatasets.Groups)</code></pre><p>Return the names of all subgroubs of the group <code>g</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L391-L395">source</a></section><h2><a class="nav-anchor" id="Common-methods-1" href="#Common-methods-1">Common methods</a></h2><p>One can iterate over a dataset, attribute list, dimensions and NetCDF groups.</p><pre><code class="language-julia">for (varname,var) in ds
    # all variables
    @show (varname,size(var))
end

for (dimname,dim) in ds.dims
    # all dimensions
    @show (dimname,dim)
end

for (attribname,attrib) in ds.attrib
    # all attributes
    @show (attribname,attrib)
end

for (groupname,group) in ds.groups
    # all groups
    @show (groupname,group)
end</code></pre><h1><a class="nav-anchor" id="Time-functions-1" href="#Time-functions-1">Time functions</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.CFTime.DateTimeStandard" href="#NCDatasets.CFTime.DateTimeStandard"><code>NCDatasets.CFTime.DateTimeStandard</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DateTimeStandard(y, [m, d, h, mi, s, ms]) -&gt; DateTimeStandard</code></pre><p>Construct a <code>DateTimeStandard</code> type by year (<code>y</code>), month (<code>m</code>, default 1), day (<code>d</code>, default 1), hour (<code>h</code>, default 0), minute (<code>mi</code>, default 0), second (<code>s</code>, default 0), millisecond (<code>ms</code>, default 0). All arguments must be convertible to <code>Int64</code>. <code>DateTimeStandard</code> is a subtype of <code>AbstractCFDateTime</code>.</p><p>The netCDF CF calendars are defined at [1].</p><p>[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L302-L314">source</a><div><div><pre><code class="language-none">       DateTimeStandard(dt::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; DateTimeStandard</code></pre><p>Construct a DateTimeStandard by parsing the <code>dt</code> date time string following the pattern given in the <code>format</code> string.</p><p>Note: This function is experimental and migth be removed in the future. It relies on some internal function of <code>Dates</code> for parsing the <code>format</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L328-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.CFTime.DateTimeJulian" href="#NCDatasets.CFTime.DateTimeJulian"><code>NCDatasets.CFTime.DateTimeJulian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DateTimeJulian(y, [m, d, h, mi, s, ms]) -&gt; DateTimeJulian</code></pre><p>Construct a <code>DateTimeJulian</code> type by year (<code>y</code>), month (<code>m</code>, default 1), day (<code>d</code>, default 1), hour (<code>h</code>, default 0), minute (<code>mi</code>, default 0), second (<code>s</code>, default 0), millisecond (<code>ms</code>, default 0). All arguments must be convertible to <code>Int64</code>. <code>DateTimeJulian</code> is a subtype of <code>AbstractCFDateTime</code>.</p><p>The netCDF CF calendars are defined at [1].</p><p>[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L302-L314">source</a><div><div><pre><code class="language-none">       DateTimeJulian(dt::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; DateTimeJulian</code></pre><p>Construct a DateTimeJulian by parsing the <code>dt</code> date time string following the pattern given in the <code>format</code> string.</p><p>Note: This function is experimental and migth be removed in the future. It relies on some internal function of <code>Dates</code> for parsing the <code>format</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L328-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.CFTime.DateTimeProlepticGregorian" href="#NCDatasets.CFTime.DateTimeProlepticGregorian"><code>NCDatasets.CFTime.DateTimeProlepticGregorian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DateTimeProlepticGregorian(y, [m, d, h, mi, s, ms]) -&gt; DateTimeProlepticGregorian</code></pre><p>Construct a <code>DateTimeProlepticGregorian</code> type by year (<code>y</code>), month (<code>m</code>, default 1), day (<code>d</code>, default 1), hour (<code>h</code>, default 0), minute (<code>mi</code>, default 0), second (<code>s</code>, default 0), millisecond (<code>ms</code>, default 0). All arguments must be convertible to <code>Int64</code>. <code>DateTimeProlepticGregorian</code> is a subtype of <code>AbstractCFDateTime</code>.</p><p>The netCDF CF calendars are defined at [1].</p><p>[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L302-L314">source</a><div><div><pre><code class="language-none">       DateTimeProlepticGregorian(dt::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; DateTimeProlepticGregorian</code></pre><p>Construct a DateTimeProlepticGregorian by parsing the <code>dt</code> date time string following the pattern given in the <code>format</code> string.</p><p>Note: This function is experimental and migth be removed in the future. It relies on some internal function of <code>Dates</code> for parsing the <code>format</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L328-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.CFTime.DateTimeAllLeap" href="#NCDatasets.CFTime.DateTimeAllLeap"><code>NCDatasets.CFTime.DateTimeAllLeap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DateTimeAllLeap(y, [m, d, h, mi, s, ms]) -&gt; DateTimeAllLeap</code></pre><p>Construct a <code>DateTimeAllLeap</code> type by year (<code>y</code>), month (<code>m</code>, default 1), day (<code>d</code>, default 1), hour (<code>h</code>, default 0), minute (<code>mi</code>, default 0), second (<code>s</code>, default 0), millisecond (<code>ms</code>, default 0). All arguments must be convertible to <code>Int64</code>. <code>DateTimeAllLeap</code> is a subtype of <code>AbstractCFDateTime</code>.</p><p>The netCDF CF calendars are defined at [1].</p><p>[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L302-L314">source</a><div><div><pre><code class="language-none">       DateTimeAllLeap(dt::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; DateTimeAllLeap</code></pre><p>Construct a DateTimeAllLeap by parsing the <code>dt</code> date time string following the pattern given in the <code>format</code> string.</p><p>Note: This function is experimental and migth be removed in the future. It relies on some internal function of <code>Dates</code> for parsing the <code>format</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L328-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.CFTime.DateTimeNoLeap" href="#NCDatasets.CFTime.DateTimeNoLeap"><code>NCDatasets.CFTime.DateTimeNoLeap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DateTimeNoLeap(y, [m, d, h, mi, s, ms]) -&gt; DateTimeNoLeap</code></pre><p>Construct a <code>DateTimeNoLeap</code> type by year (<code>y</code>), month (<code>m</code>, default 1), day (<code>d</code>, default 1), hour (<code>h</code>, default 0), minute (<code>mi</code>, default 0), second (<code>s</code>, default 0), millisecond (<code>ms</code>, default 0). All arguments must be convertible to <code>Int64</code>. <code>DateTimeNoLeap</code> is a subtype of <code>AbstractCFDateTime</code>.</p><p>The netCDF CF calendars are defined at [1].</p><p>[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L302-L314">source</a><div><div><pre><code class="language-none">       DateTimeNoLeap(dt::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; DateTimeNoLeap</code></pre><p>Construct a DateTimeNoLeap by parsing the <code>dt</code> date time string following the pattern given in the <code>format</code> string.</p><p>Note: This function is experimental and migth be removed in the future. It relies on some internal function of <code>Dates</code> for parsing the <code>format</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L328-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.CFTime.DateTime360Day" href="#NCDatasets.CFTime.DateTime360Day"><code>NCDatasets.CFTime.DateTime360Day</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DateTime360Day(y, [m, d, h, mi, s, ms]) -&gt; DateTime360Day</code></pre><p>Construct a <code>DateTime360Day</code> type by year (<code>y</code>), month (<code>m</code>, default 1), day (<code>d</code>, default 1), hour (<code>h</code>, default 0), minute (<code>mi</code>, default 0), second (<code>s</code>, default 0), millisecond (<code>ms</code>, default 0). All arguments must be convertible to <code>Int64</code>. <code>DateTime360Day</code> is a subtype of <code>AbstractCFDateTime</code>.</p><p>The netCDF CF calendars are defined at [1].</p><p>[1] https://web.archive.org/web/20180622080424/http://cfconventions.org/cf-conventions/cf-conventions.html#calendar</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L302-L314">source</a><div><div><pre><code class="language-none">       DateTime360Day(dt::AbstractString, format::AbstractString; locale=&quot;english&quot;) -&gt; DateTime360Day</code></pre><p>Construct a DateTime360Day by parsing the <code>dt</code> date time string following the pattern given in the <code>format</code> string.</p><p>Note: This function is experimental and migth be removed in the future. It relies on some internal function of <code>Dates</code> for parsing the <code>format</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L328-L337">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Dates.year(dt::AbstractCFDateTime)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Dates.month(dt::AbstractCFDateTime)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Dates.day(dt::AbstractCFDateTime)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Dates.hour(dt::AbstractCFDateTime)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Dates.minute(dt::AbstractCFDateTime)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Dates.second(dt::AbstractCFDateTime)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Dates.millisecond(dt::AbstractCFDateTime)</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dt2 = convert(::Type{T}, dt)</code></pre><p>Convert a DateTime of type <code>DateTimeStandard</code>, <code>DateTimeProlepticGregorian</code>, <code>DateTimeJulian</code> or <code>DateTime</code> into the type <code>T</code> which can also be either <code>DateTimeStandard</code>, <code>DateTimeProlepticGregorian</code>, <code>DateTimeJulian</code> or <code>DateTime</code>.</p><p>Converstion is done such that durations (difference of DateTime types) are preserved. For dates on and after 1582-10-15, the year, month and days are the same for the types <code>DateTimeStandard</code>, <code>DateTimeProlepticGregorian</code> and <code>DateTime</code>.</p><p>For dates before 1582-10-15, the year, month and days are the same for the types <code>DateTimeStandard</code> and <code>DateTimeJulian</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L405-L418">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reinterpret" href="#Base.reinterpret"><code>Base.reinterpret</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dt2 = reinterpret(::Type{T}, dt)</code></pre><p>Convert a variable <code>dt</code> of type <code>DateTime</code>, <code>DateTimeStandard</code>, <code>DateTimeJulian</code>, <code>DateTimeProlepticGregorian</code>, <code>DateTimeAllLeap</code>, <code>DateTimeNoLeap</code> or <code>DateTime360Day</code> into the date time type <code>T</code> using the same values for year, month, day, minute, second and millisecond. The convertion might fail if a particular date does not exist in the target calendar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L388-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dates.daysinmonth" href="#Dates.daysinmonth"><code>Dates.daysinmonth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">monthlength = daysinmonth(::Type{DT},y,m)</code></pre><p>Returns the number of days in a month for the year <code>y</code> and the month <code>m</code> according to the calenar given by the type <code>DT</code>.</p><p>Example</p><pre><code class="language-julia-repl">julia&gt; daysinmonth(DateTimeAllLeap,2001,2)
29</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L688-L700">source</a><div><div><pre><code class="language-none">monthlength = daysinmonth(t)</code></pre><p>Returns the number of days in a month containing the date <code>t</code></p><p>Example</p><pre><code class="language-julia-repl">julia&gt; daysinmonth(DateTimeAllLeap(2001,2,1))
29</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L706-L716">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dates.daysinyear" href="#Dates.daysinyear"><code>Dates.daysinyear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">yearlength = daysinyear(::Type{DT},y)</code></pre><p>Returns the number of days in a year for the year <code>y</code> according to the calenar given by the type <code>DT</code>.</p><p>Example</p><pre><code class="language-julia-repl">julia&gt; daysinyear(DateTimeAllLeap,2001,2)
366</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L721-L733">source</a><div><div><pre><code class="language-none">yearlength = daysinyear(t)</code></pre><p>Returns the number of days in a year containing the date <code>t</code></p><p>Example</p><pre><code class="language-julia-repl">julia&gt; daysinyear(DateTimeAllLeap(2001,2,1))
366</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L739-L749">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dates.yearmonthday" href="#Dates.yearmonthday"><code>Dates.yearmonthday</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">yearmonthday(dt::AbstractCFDateTime) -&gt; (Int64, Int64, Int64)</code></pre><p>Simultaneously return the year, month and day parts of <code>dt</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L754-L758">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dates.yearmonth" href="#Dates.yearmonth"><code>Dates.yearmonth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">yearmonth(dt::AbstractCFDateTime) -&gt; (Int64, Int64)</code></pre><p>Simultaneously return the year and month parts of <code>dt</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L761-L765">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dates.monthday" href="#Dates.monthday"><code>Dates.monthday</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">monthday(dt::AbstractCFDateTime) -&gt; (Int64, Int64)</code></pre><p>Simultaneously return the month and day parts of <code>dt</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L768-L772">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.CFTime.timedecode" href="#NCDatasets.CFTime.timedecode"><code>NCDatasets.CFTime.timedecode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dt = timedecode(data,units,calendar = &quot;standard&quot;, prefer_datetime = true)</code></pre><p>Decode the time information in data as given by the units <code>units</code> according to the specified calendar. Valid values for <code>calendar</code> are &quot;standard&quot;, &quot;gregorian&quot;, &quot;proleptic<em>gregorian&quot;, &quot;julian&quot;, &quot;noleap&quot;, &quot;365</em>day&quot;, &quot;all<em>leap&quot;, &quot;366</em>day&quot; and &quot;360_day&quot;.</p><p>If <code>prefer_datetime</code> is <code>true</code> (default), dates are converted to the <code>DateTime</code> type (for the calendars &quot;standard&quot;, &quot;gregorian&quot;, &quot;proleptic_gregorian&quot; and &quot;julian&quot;). Such convertion is not possible for the other calendars.</p><table><tr><th style="text-align: right">Calendar</th><th style="text-align: right">Type (prefer_datetime=true)</th><th style="text-align: right">Type (prefer_datetime=false)</th></tr><tr><td style="text-align: right">standard, gregorian</td><td style="text-align: right">DateTime</td><td style="text-align: right">DateTimeStandard</td></tr><tr><td style="text-align: right">proleptic_gregorian</td><td style="text-align: right">DateTime</td><td style="text-align: right">DateTimeProlepticGregorian</td></tr><tr><td style="text-align: right">julian</td><td style="text-align: right">DateTime</td><td style="text-align: right">DateTimeJulian</td></tr><tr><td style="text-align: right">noleap, 365_day</td><td style="text-align: right">DateTimeNoLeap</td><td style="text-align: right">DateTimeNoLeap</td></tr><tr><td style="text-align: right">all<em>leap, 366</em>day</td><td style="text-align: right">DateTimeAllLeap</td><td style="text-align: right">DateTimeAllLeap</td></tr><tr><td style="text-align: right">360_day</td><td style="text-align: right">DateTime360Day</td><td style="text-align: right">DateTime360Day</td></tr></table></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L593-L615">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.CFTime.timeencode" href="#NCDatasets.CFTime.timeencode"><code>NCDatasets.CFTime.timeencode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">data = timeencode(dt,units,calendar = &quot;standard&quot;)</code></pre><p>Convert a vector or array of <code>DateTime</code> (or <code>DateTimeStandard</code>, <code>DateTimeProlepticGregorian</code>, <code>DateTimeJulian</code>, <code>DateTimeNoLeap</code>, <code>DateTimeAllLeap</code>, <code>DateTime360Day</code>) accoring to the specified units (e.g. &quot;days since 2000-01-01 00:00:00&quot;) using the calendar <code>calendar</code>.  Valid values for calendar are: &quot;standard&quot;, &quot;gregorian&quot;, &quot;proleptic<em>gregorian&quot;, &quot;julian&quot;, &quot;noleap&quot;, &quot;365</em>day&quot;, &quot;all<em>leap&quot;, &quot;366</em>day&quot;, &quot;360_day&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/CFTime.jl#L638-L648">source</a></section><h1><a class="nav-anchor" id="Utility-functions-1" href="#Utility-functions-1">Utility functions</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.ncgen" href="#NCDatasets.ncgen"><code>NCDatasets.ncgen</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ncgen(fname; ...)
ncgen(fname,jlname; ...)</code></pre><p>Generate the Julia code that would produce a NetCDF file with the same metadata as the NetCDF file <code>fname</code>. The code is placed in the file <code>jlname</code> or printed to the standard output. By default the new NetCDF file is called <code>filename.nc</code>. This can be changed with the optional parameter <code>newfname</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L1500-L1508">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.nomissing" href="#NCDatasets.nomissing"><code>NCDatasets.nomissing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">a = nomissing(da)</code></pre><p>Retun the values of the array <code>da</code> of type <code>Array{Union{T,Missing},N}</code> (potentially containing missing values) as a regular Julia array <code>a</code> of the same element type and checks that no missing values are present.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L1588-L1595">source</a><div><div><pre><code class="language-none">a = nomissing(da,value)</code></pre><p>Retun the values of the array <code>da</code> of type <code>Array{Union{T,Missing},N}</code> as a regular Julia array <code>a</code> by replacing all missing value by <code>value</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L1613-L1618">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.varbyattrib" href="#NCDatasets.varbyattrib"><code>NCDatasets.varbyattrib</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">varbyattrib(ds, attname = attval)</code></pre><p>Returns a list of variable(s) which has the attribute <code>attname</code> matching the value <code>attval</code> in the dataset <code>ds</code>. The list is empty if the none of the variables has the match. The output is a list of <code>CFVariable</code>s.</p><p><strong>Examples</strong></p><p>Load all the data of the first variable with standard name &quot;longitude&quot; from the NetCDF file <code>results.nc</code>.</p><pre><code class="language-julia-repl">julia&gt; ds = Dataset(&quot;results.nc&quot;, &quot;r&quot;);
julia&gt; data = varbyattrib(ds, standard_name = &quot;longitude&quot;)[1][:]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/NCDatasets.jl#L1534-L1552">source</a></section><h1><a class="nav-anchor" id="Multi-file-support-(experimental)-1" href="#Multi-file-support-(experimental)-1">Multi-file support (experimental)</a></h1><p>Multiple files can also be aggregated over a given dimensions (or the record dimension). In this example, 3 sea surface temperature fields from the 1992-01-01 to 1992-01-03 are aggregated using the OpenDAP service from PODAAC.</p><pre><code class="language-none">using NCDatasets, Printf, Dates

function url(dt)
  doy = @sprintf(&quot;%03d&quot;,Dates.dayofyear(dt))
  y = @sprintf(&quot;%04d&quot;,Dates.year(dt))
  yyyymmdd = Dates.format(dt,&quot;yyyymmdd&quot;)
  return &quot;https://podaac-opendap.jpl.nasa.gov:443/opendap/allData/ghrsst/data/GDS2/L4/GLOB/CMC/CMC0.2deg/v2/$y/$doy/$(yyyymmdd)120000-CMC-L4_GHRSST-SSTfnd-CMC0.2deg-GLOB-v02.0-fv02.0.nc&quot;
end

ds = Dataset(url.(DateTime(1992,1,1):Dates.Day(1):DateTime(1992,1,3)),aggdim = &quot;time&quot;);
SST2 = ds[&quot;analysed_sst&quot;][:,:,:];
close(ds)</code></pre><p>If there is a network or server issue, you will see an error message like &quot;NetCDF: I/O failure&quot;.</p><h1><a class="nav-anchor" id="Experimental-functions-1" href="#Experimental-functions-1">Experimental functions</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.ancillaryvariables" href="#NCDatasets.ancillaryvariables"><code>NCDatasets.ancillaryvariables</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ncvar = NCDatasets.ancillaryvariables(ncv::NCDatasets.CFVariable,modifier)</code></pre><p>Return the first ancillary variables from the NetCDF variable <code>ncv</code> with the standard name modifier <code>modifier</code>. It can be used for example to access related variable like status flags.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/cfconventions.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NCDatasets.filter" href="#NCDatasets.filter"><code>NCDatasets.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">data = NCDatasets.filter(ncv, indices...; accepted_status_flags = nothing)</code></pre><p>Load and filter observations by replacing all variables without an acepted status flag to <code>missing</code>. It is used the attribute <code>ancillary_variables</code> to identify the status flag.</p><pre><code class="language-none"># da[&quot;data&quot;] is 2D matrix
good_data = NCDatasets.filter(ds[&quot;data&quot;],:,:, accepted_status_flags = [&quot;good_data&quot;,&quot;probably_good_data&quot;])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Alexander-Barth/NCDatasets.jl/blob/84b98ec2d4f4094ccc45ac835030ec5026e7c6dc/src/cfconventions.jl#L30-L42">source</a></section><h1><a class="nav-anchor" id="Issues-1" href="#Issues-1">Issues</a></h1><h2><a class="nav-anchor" id="libnetcdf-not-properly-installed-1" href="#libnetcdf-not-properly-installed-1">libnetcdf not properly installed</a></h2><p>If you see the following error,</p><pre><code class="language-none">ERROR: LoadError: LoadError: libnetcdf not properly installed. Please run Pkg.build(&quot;NCDatasets&quot;)</code></pre><p>you can try to install netcdf explicitly with Conda:</p><pre><code class="language-julia">using Conda
Conda.add(&quot;libnetcdf&quot;)</code></pre><h2><a class="nav-anchor" id="NetCDF:-Not-a-valid-data-type-or-_FillValue-type-mismatch-1" href="#NetCDF:-Not-a-valid-data-type-or-_FillValue-type-mismatch-1">NetCDF: Not a valid data type or _FillValue type mismatch</a></h2><p>Trying to define the <code>_FillValue</code>, procudes the following error:</p><pre><code class="language-none">ERROR: LoadError: NCDatasets.NetCDFError(-45, &quot;NetCDF: Not a valid data type or _FillValue type mismatch&quot;)</code></pre><p>The error could be generated by a code like this:</p><pre><code class="language-julia">using NCDatasets
# ...
tempvar = defVar(ds,&quot;temp&quot;,Float32,(&quot;lonc&quot;,&quot;latc&quot;,&quot;time&quot;))
tempvar.attrib[&quot;_FillValue&quot;] = -9999.</code></pre><p>In fact, <code>_FillValue</code> must have the same data type as the corresponding variable. In the case above, <code>tempvar</code> is a 32-bit float and the number <code>-9999.</code> is a 64-bit float (aka double, which is the default floating point type in Julia). It is sufficient to convert the value <code>-9999.</code> to a 32-bit float:</p><pre><code class="language-julia">tempvar.attrib[&quot;_FillValue&quot;] = Float32(-9999.) # or
tempvar.attrib[&quot;_FillValue&quot;] = -9999.f0</code></pre><h2><a class="nav-anchor" id="Corner-cases-1" href="#Corner-cases-1">Corner cases</a></h2><ul><li><p>An attribute representing a vector with a single value (e.g. <code>[1]</code>) will be read back as a scalar (<code>1</code>) (same behavior in python netCDF4 1.3.1).</p></li><li><p>NetCDF and Julia distinguishes between a vector of chars and a string, but both are returned as string for ease of use, in particular an attribute representing a vector of chars <code>[&#39;u&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;,&#39;s&#39;]</code> will be read back as the string <code>&quot;units&quot;</code>.</p></li><li><p>An attribute representing a vector of chars <code>[&#39;u&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;,&#39;s&#39;,&#39;\0&#39;]</code> will also be read back as the string <code>&quot;units&quot;</code> (issue #12).</p></li></ul><footer><hr/></footer></article></body></html>
