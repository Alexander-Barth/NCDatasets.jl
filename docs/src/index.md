# NCDatasets.jl

Documentation for NCDatasets.jl

## Datasets

```@docs
Dataset
keys(ds::Dataset)
haskey
getindex(ds::Dataset,varname::AbstractString)
variable
sync
close
path
```

## Variables

```@docs
defVar
dimnames
name
chunking
deflate
checksum
```

Different type of arrays are involved when working with NCDatasets. For instance assume that `test.nc` is a file with a `Float32` variable called `var`. Assume that we open this data set in append mode (`"a"`):

```julia
using NCDatasets
ds = Dataset("test.nc","a")
v_cf = ds["var"]
```

The variable `v_cf` has the type `CFVariable`. No data is actually loaded from disk, but you can query its size, number of dimensions, number elements, ... by the functions `size`, `ndims`, `length` as ordinary Julia arrays. Once you index, the variable `v_cf`, then the data is loaded and stored into a `DataArray`:

```julia
v_da = v_cf[:,:]
```



## Attributes

The NetCDF dataset (as return by `Dataset` or NetCDF groups) and the NetCDF variables (as returned by `getindex`, `variable` or `defVar`) have the field `attrib` which has the type `NCDatasets.Attributes` and behaves like a julia dictionary.


```@docs
getindex(a::NCDatasets.Attributes,name::AbstractString)
setindex!(a::NCDatasets.Attributes,data,name::AbstractString)
keys(a::NCDatasets.Attributes)
```

## Dimensions

```@docs
defDim
setindex!(d::NCDatasets.Dimensions,len,name::AbstractString)
dimnames(v::NCDatasets.Variable)
```


## Groups

```@docs
defGroup(ds::Dataset,groupname)
getindex(g::NCDatasets.Groups,groupname::AbstractString)
Base.keys(g::NCDatasets.Groups)
```

## Common methods

Explore a NetCDF dataset

```@docs
Base.start(a::NCDatasets.NCIterable)
```



# Time functions

```@docs
DateTimeStandard
DateTimeJulian
DateTimeProlepticGregorian
DateTimeAllLeap
DateTimeNoLeap
DateTime360Day
Dates.year(dt::AbstractCFDateTime)
Dates.month(dt::AbstractCFDateTime)
Dates.day(dt::AbstractCFDateTime)
Dates.hour(dt::AbstractCFDateTime)
Dates.minute(dt::AbstractCFDateTime)
Dates.second(dt::AbstractCFDateTime)
Dates.millisecond(dt::AbstractCFDateTime)
convert
reinterpret
timedecode
timeencode
```


# Utility functions

```@docs
ncgen(fname)
nomissing(da::DataArrays.DataArray)
nomissing(da::DataArrays.DataArray,value)
varbyattrib
```


# Issues

## libnetcdf not properly installed

If you see the following error,

```
ERROR: LoadError: LoadError: libnetcdf not properly installed. Please run Pkg.build("NCDatasets")
```

you can try to install netcdf explicitly with Conda:

```julia
using Conda
Conda.add("libnetcdf")
```

## NetCDF: Not a valid data type or _FillValue type mismatch

Trying to define the `_FillValue`, procudes the following error:

```
ERROR: LoadError: NCDatasets.NetCDFError(-45, "NetCDF: Not a valid data type or _FillValue type mismatch")
```

The error could be generated by a code like this:

```julia
using NCDatasets
# ...
tempvar = defVar(ds,"temp",Float32,("lonc","latc","time"))
tempvar.attrib["_FillValue"] = -9999.
```

In fact, `_FillValue` must have the same data type as the corresponding variable. In the case above, `tempvar` is a 32-bit float and the number `-9999.` is a 64-bit float (aka double, which is the default floating point type in Julia). It is sufficient to convert the value `-9999.` to a 32-bit float:

```julia
tempvar.attrib["_FillValue"] = Float32(-9999.)
```


## Corner cases


* An attribute representing a vector with a single value (e.g. `[1]`) will be read back as a scalar (`1`) (same behavior in python netCDF4 1.3.1).

* NetCDF and Julia distinguishes between a vector of chars and a string, but both are returned as string for ease of use, in particular 
an attribute representing a vector of chars `['u','n','i','t','s']` will be read back as the string `"units"`.

* An attribute representing a vector of chars `['u','n','i','t','s','\0']` will also be read back as the string `"units"` (issue #12).


<!--  LocalWords:  NCDatasets jl Datasets Dataset netCDF
 -->
